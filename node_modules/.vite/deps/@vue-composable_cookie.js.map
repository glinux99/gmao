{
  "version": 3,
  "sources": ["../../@vue/devtools-api/lib/esm/env.js", "../../@vue/devtools-api/lib/esm/const.js", "../../@vue/devtools-api/lib/esm/time.js", "../../@vue/devtools-api/lib/esm/proxy.js", "../../@vue/devtools-api/lib/esm/api/api.js", "../../@vue/devtools-api/lib/esm/api/app.js", "../../@vue/devtools-api/lib/esm/api/component.js", "../../@vue/devtools-api/lib/esm/api/context.js", "../../@vue/devtools-api/lib/esm/api/hooks.js", "../../@vue/devtools-api/lib/esm/api/util.js", "../../@vue/devtools-api/lib/esm/api/index.js", "../../@vue/devtools-api/lib/esm/plugin.js", "../../@vue/devtools-api/lib/esm/index.js", "../../js-cookie/dist/js.cookie.mjs", "../../vue-composable/dist/vue-composable.esm-bundler.js", "../../@vue-composable/cookie/dist/cookie.esm-bundler.js"],
  "sourcesContent": ["export function getDevtoolsGlobalHook() {\n    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;\n}\nexport function getTarget() {\n    // @ts-expect-error navigator and windows are not available in all environments\n    return (typeof navigator !== 'undefined' && typeof window !== 'undefined')\n        ? window\n        : typeof globalThis !== 'undefined'\n            ? globalThis\n            : {};\n}\nexport const isProxyAvailable = typeof Proxy === 'function';\n", "export const HOOK_SETUP = 'devtools-plugin:setup';\nexport const HOOK_PLUGIN_SETTINGS_SET = 'plugin:settings:set';\n", "let supported;\nlet perf;\nexport function isPerformanceSupported() {\n    var _a;\n    if (supported !== undefined) {\n        return supported;\n    }\n    if (typeof window !== 'undefined' && window.performance) {\n        supported = true;\n        perf = window.performance;\n    }\n    else if (typeof globalThis !== 'undefined' && ((_a = globalThis.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {\n        supported = true;\n        perf = globalThis.perf_hooks.performance;\n    }\n    else {\n        supported = false;\n    }\n    return supported;\n}\nexport function now() {\n    return isPerformanceSupported() ? perf.now() : Date.now();\n}\n", "import { HOOK_PLUGIN_SETTINGS_SET } from './const.js';\nimport { now } from './time.js';\nexport class ApiProxy {\n    constructor(plugin, hook) {\n        this.target = null;\n        this.targetQueue = [];\n        this.onQueue = [];\n        this.plugin = plugin;\n        this.hook = hook;\n        const defaultSettings = {};\n        if (plugin.settings) {\n            for (const id in plugin.settings) {\n                const item = plugin.settings[id];\n                defaultSettings[id] = item.defaultValue;\n            }\n        }\n        const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;\n        let currentSettings = Object.assign({}, defaultSettings);\n        try {\n            const raw = localStorage.getItem(localSettingsSaveId);\n            const data = JSON.parse(raw);\n            Object.assign(currentSettings, data);\n        }\n        catch (e) {\n            // noop\n        }\n        this.fallbacks = {\n            getSettings() {\n                return currentSettings;\n            },\n            setSettings(value) {\n                try {\n                    localStorage.setItem(localSettingsSaveId, JSON.stringify(value));\n                }\n                catch (e) {\n                    // noop\n                }\n                currentSettings = value;\n            },\n            now() {\n                return now();\n            },\n        };\n        if (hook) {\n            hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {\n                if (pluginId === this.plugin.id) {\n                    this.fallbacks.setSettings(value);\n                }\n            });\n        }\n        this.proxiedOn = new Proxy({}, {\n            get: (_target, prop) => {\n                if (this.target) {\n                    return this.target.on[prop];\n                }\n                else {\n                    return (...args) => {\n                        this.onQueue.push({\n                            method: prop,\n                            args,\n                        });\n                    };\n                }\n            },\n        });\n        this.proxiedTarget = new Proxy({}, {\n            get: (_target, prop) => {\n                if (this.target) {\n                    return this.target[prop];\n                }\n                else if (prop === 'on') {\n                    return this.proxiedOn;\n                }\n                else if (Object.keys(this.fallbacks).includes(prop)) {\n                    return (...args) => {\n                        this.targetQueue.push({\n                            method: prop,\n                            args,\n                            resolve: () => { },\n                        });\n                        return this.fallbacks[prop](...args);\n                    };\n                }\n                else {\n                    return (...args) => {\n                        return new Promise((resolve) => {\n                            this.targetQueue.push({\n                                method: prop,\n                                args,\n                                resolve,\n                            });\n                        });\n                    };\n                }\n            },\n        });\n    }\n    async setRealTarget(target) {\n        this.target = target;\n        for (const item of this.onQueue) {\n            this.target.on[item.method](...item.args);\n        }\n        for (const item of this.targetQueue) {\n            item.resolve(await this.target[item.method](...item.args));\n        }\n    }\n}\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export {};\n", "export * from './api.js';\nexport * from './app.js';\nexport * from './component.js';\nexport * from './context.js';\nexport * from './hooks.js';\nexport * from './util.js';\n", "export {};\n", "import { getDevtoolsGlobalHook, getTarget, isProxyAvailable } from './env.js';\nimport { HOOK_SETUP } from './const.js';\nimport { ApiProxy } from './proxy.js';\nexport * from './api/index.js';\nexport * from './plugin.js';\nexport * from './time.js';\nexport function setupDevtoolsPlugin(pluginDescriptor, setupFn) {\n    const descriptor = pluginDescriptor;\n    const target = getTarget();\n    const hook = getDevtoolsGlobalHook();\n    const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;\n    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {\n        hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);\n    }\n    else {\n        const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;\n        const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];\n        list.push({\n            pluginDescriptor: descriptor,\n            setupFn,\n            proxy,\n        });\n        if (proxy) {\n            setupFn(proxy.proxiedTarget);\n        }\n    }\n}\n", "/*! js-cookie v3.0.5 | MIT */\n/* eslint-disable no-var */\nfunction assign (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      target[key] = source[key];\n    }\n  }\n  return target\n}\n/* eslint-enable no-var */\n\n/* eslint-disable no-var */\nvar defaultConverter = {\n  read: function (value) {\n    if (value[0] === '\"') {\n      value = value.slice(1, -1);\n    }\n    return value.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent)\n  },\n  write: function (value) {\n    return encodeURIComponent(value).replace(\n      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,\n      decodeURIComponent\n    )\n  }\n};\n/* eslint-enable no-var */\n\n/* eslint-disable no-var */\n\nfunction init (converter, defaultAttributes) {\n  function set (name, value, attributes) {\n    if (typeof document === 'undefined') {\n      return\n    }\n\n    attributes = assign({}, defaultAttributes, attributes);\n\n    if (typeof attributes.expires === 'number') {\n      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);\n    }\n    if (attributes.expires) {\n      attributes.expires = attributes.expires.toUTCString();\n    }\n\n    name = encodeURIComponent(name)\n      .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)\n      .replace(/[()]/g, escape);\n\n    var stringifiedAttributes = '';\n    for (var attributeName in attributes) {\n      if (!attributes[attributeName]) {\n        continue\n      }\n\n      stringifiedAttributes += '; ' + attributeName;\n\n      if (attributes[attributeName] === true) {\n        continue\n      }\n\n      // Considers RFC 6265 section 5.2:\n      // ...\n      // 3.  If the remaining unparsed-attributes contains a %x3B (\";\")\n      //     character:\n      // Consume the characters of the unparsed-attributes up to,\n      // not including, the first %x3B (\";\") character.\n      // ...\n      stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];\n    }\n\n    return (document.cookie =\n      name + '=' + converter.write(value, name) + stringifiedAttributes)\n  }\n\n  function get (name) {\n    if (typeof document === 'undefined' || (arguments.length && !name)) {\n      return\n    }\n\n    // To prevent the for loop in the first place assign an empty array\n    // in case there are no cookies at all.\n    var cookies = document.cookie ? document.cookie.split('; ') : [];\n    var jar = {};\n    for (var i = 0; i < cookies.length; i++) {\n      var parts = cookies[i].split('=');\n      var value = parts.slice(1).join('=');\n\n      try {\n        var found = decodeURIComponent(parts[0]);\n        jar[found] = converter.read(value, found);\n\n        if (name === found) {\n          break\n        }\n      } catch (e) {}\n    }\n\n    return name ? jar[name] : jar\n  }\n\n  return Object.create(\n    {\n      set,\n      get,\n      remove: function (name, attributes) {\n        set(\n          name,\n          '',\n          assign({}, attributes, {\n            expires: -1\n          })\n        );\n      },\n      withAttributes: function (attributes) {\n        return init(this.converter, assign({}, this.attributes, attributes))\n      },\n      withConverter: function (converter) {\n        return init(assign({}, this.converter, converter), this.attributes)\n      }\n    },\n    {\n      attributes: { value: Object.freeze(defaultAttributes) },\n      converter: { value: Object.freeze(converter) }\n    }\n  )\n}\n\nvar api = init(defaultConverter, { path: '/' });\n/* eslint-enable no-var */\n\nexport { api as default };\n", "import { isRef, ref, watch, onMounted, toRaw, getCurrentInstance, onUnmounted, computed, inject, reactive, unref, onActivated, onDeactivated, onBeforeUnmount, customRef, provide, watchEffect, readonly } from 'vue';\n\nfunction unwrap(o) {\n    return isRef(o) ? o.value : o;\n    // return unref(o) as T;\n}\nfunction wrap(o) {\n    return isRef(o) ? o : ref(o); // NOTE in v3 this is not necessary\n}\nconst isArray = Array.isArray;\nconst isFunction = (val) => typeof val === \"function\";\nconst isString = (val) => typeof val === \"string\";\nconst isSymbol = (val) => typeof val === \"symbol\";\nconst isBoolean = (val) => typeof val === \"boolean\";\nconst isUndefined = (val) => typeof val === \"undefined\";\nconst isNull = (val) => val === null;\nconst isDate = (val) => isObject(val) && isFunction(val.getTime);\nconst isNumber = (val) => typeof val === \"number\";\nconst isObject = (val) => val !== null && typeof val === \"object\";\nconst isElement = (val) => isObject(val) && !!val.tagName;\nfunction isPromise(val) {\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n}\nconst NO_OP = () => { };\nconst FALSE_OP = () => false;\nconst PASSIVE_EV = { passive: true };\nfunction promisedTimeout(timeout) {\n    return new Promise((res) => {\n        setTimeout(res, timeout);\n    });\n}\n// https://v8.dev/blog/react-cliff\nconst MAX_ARRAY_SIZE = 2 ** 32 - 2;\nfunction minMax(val, min, max) {\n    if (val < min)\n        return min;\n    if (val > max)\n        return max;\n    return val;\n}\nconst isClient = typeof window != \"undefined\";\nfunction deepClone(result, ...sources) {\n    for (let i = 0; i < sources.length; i++) {\n        const source = sources[i];\n        if (source === undefined || !isObject(source))\n            continue;\n        const keys = Object.keys(source);\n        for (let j = 0; j < keys.length; j++) {\n            const k = keys[j];\n            const v = unwrap(source[k]);\n            const sourceType = typeof v;\n            const type = typeof result[k];\n            if (result[k] === undefined || sourceType === type) {\n                result[k] = isObject(v)\n                    ? deepClone(result[k] || {}, v)\n                    : source[k]; // source[k] is assigned because if is ref we want to override to this ref\n            }\n        }\n    }\n    return result;\n}\n// compact version: https://stackoverflow.com/a/33146982/1209882\n/**\n * returns a random string\n * @param len length of the string max: 36\n */\n// export function randomString(len: number) {\n//   return (+new Date).toString(36).slice(-len);\n// }\n\nfunction useEvent(el, name, listener, options) {\n    let remove = NO_OP;\n    if (el) {\n        const element = wrap(el);\n        const removeEventListener = (e) => e.removeEventListener(name, listener);\n        const addEventListener = (e) => e.addEventListener(name, listener, options);\n        const removeWatch = watch(element, (n, _, cleanUp) => {\n            if (n) {\n                addEventListener(n);\n                cleanUp(() => removeEventListener(n));\n            }\n        }, { immediate: true });\n        remove = () => {\n            removeEventListener(element.value);\n            removeWatch();\n        };\n    }\n    return remove;\n}\n\n/**\n * Create `debounced` function, options object can be changed after creation to update behaviour\n * @param handler - function to be debounced\n * @param wait - debounce ms\n * @param options - debounce options\n */\nfunction useDebounce(handler, wait, options) {\n    return debounce(handler, wait, options);\n}\nfunction debounce(func, waitMilliseconds = 50, options = {\n    isImmediate: false\n}) {\n    let timeoutId;\n    return function (...args) {\n        const context = this;\n        const doLater = function () {\n            timeoutId = undefined;\n            if (!options.isImmediate) {\n                func.apply(context, args);\n            }\n        };\n        const shouldCallNow = options.isImmediate && timeoutId === undefined;\n        if (timeoutId !== undefined) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(doLater, waitMilliseconds);\n        if (shouldCallNow) {\n            func.apply(context, args);\n        }\n    };\n}\n\nfunction useOnMouseMove(el, options, wait) {\n    const mouseX = ref(0);\n    const mouseY = ref(0);\n    const pageX = ref(0);\n    const pageY = ref(0);\n    let handler = (ev) => {\n        mouseX.value = ev.x;\n        mouseY.value = ev.y;\n        pageX.value = ev.pageX;\n        pageY.value = ev.pageY;\n    };\n    const [eventOptions, ms] = isNumber(options)\n        ? [undefined, options]\n        : [options, wait];\n    if (ms) {\n        handler = useDebounce(handler, wait);\n    }\n    const remove = useEvent(el, \"mousemove\", handler, eventOptions);\n    return {\n        mouseX,\n        mouseY,\n        pageX,\n        pageY,\n        remove,\n    };\n}\n\nfunction useOnResize(el, options, wait) {\n    const element = wrap(el);\n    const height = ref(element.value && element.value.clientHeight);\n    const width = ref(element.value && element.value.clientWidth);\n    let handler = () => {\n        height.value = element.value.clientHeight;\n        width.value = element.value.clientWidth;\n    };\n    const [eventOptions, ms] = isNumber(options)\n        ? [undefined, options]\n        : [options, wait];\n    if (ms) {\n        handler = useDebounce(handler, wait);\n    }\n    // resize seems only to be fired against the window\n    const remove = isClient\n        ? useEvent(window, \"resize\", handler, eventOptions || PASSIVE_EV)\n        : /* istanbul ignore next */ NO_OP;\n    if (isRef(el) && !el.value) {\n        onMounted(handler);\n    }\n    return {\n        height,\n        width,\n        remove\n    };\n}\n\nconst SCROLL_METHODS = [\"scrollBy\", \"scrollTo\", \"scrollIntoView\"];\nfunction useOnScroll(el, options, wait) {\n    const isValidElement = (el) => isNumber(el) || isBoolean(el) || !(isElement(el) || isRef(el)) || !el\n        ? false\n        : true;\n    const element = isValidElement(el)\n        ? wrap(el)\n        : ref((isClient && window) || undefined);\n    const scrollableElement = isValidElement(el)\n        ? element\n        : ref((isClient && window.document.scrollingElement) || undefined);\n    const scrollTop = ref((scrollableElement.value && scrollableElement.value.scrollTop) || 0);\n    const scrollLeft = ref((scrollableElement.value && scrollableElement.value.scrollLeft) || 0);\n    let handler = () => {\n        scrollTop.value = scrollableElement.value.scrollTop;\n        scrollLeft.value = scrollableElement.value.scrollLeft;\n    };\n    const methods = SCROLL_METHODS.reduce((p, c) => {\n        //@ts-ignore\n        p[c] = (...args) => \n        //@ts-ignore\n        scrollableElement.value &&\n            //@ts-ignore\n            scrollableElement.value[c] &&\n            //@ts-ignore\n            scrollableElement.value[c].apply(scrollableElement.value, args);\n        return p;\n    }, {});\n    const scrollTopTo = (top) => methods.scrollTo({ top });\n    const scrollLeftTo = (left) => methods.scrollTo({ left });\n    const [eventOptions, ms] = isNumber(el) || !el\n        ? [PASSIVE_EV, el]\n        : isNumber(options)\n            ? [PASSIVE_EV, options]\n            : [options, wait];\n    if (ms) {\n        handler = useDebounce(handler, wait);\n    }\n    const eventRemove = useEvent(element, \"scroll\", handler, eventOptions);\n    const watchRemoveTop = watch(scrollTop, scrollTopTo, { immediate: false });\n    const watchRemoveLeft = watch(scrollLeft, scrollLeftTo, { immediate: false });\n    const remove = () => {\n        eventRemove();\n        watchRemoveLeft();\n        watchRemoveTop();\n    };\n    return {\n        scrollTop,\n        scrollLeft,\n        remove,\n        scrollTopTo,\n        scrollLeftTo,\n        ...methods,\n    };\n}\n\nconst events = [\"mousedown\", \"touchstart\"];\nfunction useOnOutsidePress(el, onOutsidePressCallback) {\n    if (!isClient) {\n        return () => { };\n    }\n    const element = wrap(el);\n    const handler = (e) => element.value &&\n        !element.value.contains(e.target) &&\n        onOutsidePressCallback(e);\n    const event = events.find(x => `on${x}` in document.documentElement);\n    return useEvent(document, event, handler, { passive: true });\n}\n\nfunction usePromise(fn, lazyOptions) {\n    if (!fn) {\n        throw new Error(`[usePromise] argument can't be '${fn}'`);\n    }\n    if (typeof fn !== \"function\") {\n        throw new Error(`[usePromise] expects function, but received ${typeof fn}`);\n    }\n    const [lazy, throwException] = isBoolean(lazyOptions)\n        ? [lazyOptions, false]\n        : isObject(lazyOptions)\n            ? [lazyOptions.lazy, lazyOptions.throwException]\n            : [false, false];\n    const loading = ref(false);\n    const error = ref(null);\n    const result = ref(null);\n    const promise = ref();\n    const exec = async (...args) => {\n        loading.value = true;\n        error.value = null;\n        const throwExp = args &&\n            fn.length !== args.length &&\n            args.length > 0 &&\n            isBoolean(args[args.length - 1])\n            ? args[args.length - 1]\n            : throwException;\n        const currentPromise = (promise.value = fn(...args));\n        try {\n            const r = await currentPromise;\n            if (promise.value === currentPromise) {\n                result.value = r;\n            }\n            return r;\n        }\n        catch (er) {\n            if (toRaw(promise.value) === toRaw(currentPromise)) {\n                error.value = er;\n                result.value = null;\n            }\n            // if(throwExp){\n            //   throw er\n            // }\n            // return undefined\n            return throwExp ? currentPromise : undefined;\n        }\n        finally {\n            if (promise.value === currentPromise) {\n                loading.value = false;\n            }\n        }\n    };\n    if (!lazy) {\n        /* istanbul ignore else */\n        if ((process.env.NODE_ENV !== 'production')) {\n            if (fn.length > 0 &&\n                !isBoolean(isObject(lazyOptions) ? lazyOptions.lazy : lazyOptions)) {\n                console.warn(\"[usePromise] parameters detected on `fn` factory. Executing promise without arguments.\");\n            }\n        }\n        // @ts-ignore\n        exec();\n    }\n    return {\n        exec,\n        result,\n        promise,\n        loading,\n        error,\n    };\n}\n\nfunction useCancellablePromise(fn, lazyOptions) {\n    const cancelled = ref(false);\n    let _cancel = undefined;\n    const cancel = (result) => {\n        if (!_cancel) {\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                console.warn(\"[useCancellablePromise] There's no promise to cancel. Please make sure to call `exec`\");\n            }\n            return;\n        }\n        _cancel(result);\n    };\n    const promise = (p) => new Promise((res, rej) => {\n        cancelled.value = false;\n        _cancel = (result) => {\n            cancelled.value = true;\n            rej(result);\n        };\n        p.then(res).catch(rej);\n    });\n    const use = usePromise((...args) => promise(fn(...args)), lazyOptions);\n    if (getCurrentInstance() &&\n        (!isObject(lazyOptions) || lazyOptions.unmountCancel !== false)) {\n        onUnmounted(() => _cancel && _cancel());\n    }\n    return {\n        ...use,\n        cancel,\n        cancelled,\n    };\n}\n\nconst MAX_RETRIES = 9000;\n/* istanbul ignore next */\nconst ExecutionId = /*#__PURE__*/ Symbol(((process.env.NODE_ENV !== 'production') && \"RetryId\") || ``);\n/* istanbul ignore next */\nconst CancellationToken = /*#__PURE__*/ Symbol(((process.env.NODE_ENV !== 'production') && \"CancellationToken\") || ``);\nconst defaultStrategy = async (options, context, factory, args) => {\n    const retryId = context[ExecutionId].value;\n    let i = -1;\n    const maxRetries = options.maxRetries || MAX_RETRIES + 1;\n    const delay = options.retryDelay || noDelay;\n    context.retryErrors.value = [];\n    context.isRetrying.value = false;\n    context.nextRetry.value = undefined;\n    let nextRetry = undefined;\n    do {\n        let success = false;\n        let result = null;\n        try {\n            ++i;\n            if (args) {\n                result = factory(...args);\n            }\n            else {\n                result = factory();\n            }\n            if (isPromise(result)) {\n                result = await result;\n            }\n            // is cancelled?\n            if (context[CancellationToken].value) {\n                return null;\n            }\n            success = true;\n        }\n        catch (error) {\n            result = null;\n            context.retryErrors.value.push(error);\n        }\n        // is our retry current one?\n        if (retryId !== context[ExecutionId].value) {\n            return result;\n        }\n        if (success) {\n            context.isRetrying.value = false;\n            context.nextRetry.value = undefined;\n            return result;\n        }\n        if (i >= maxRetries) {\n            context.isRetrying.value = false;\n            context.nextRetry.value = undefined;\n            return Promise.reject(new Error(`[useRetry] max retries reached ${maxRetries}`));\n        }\n        context.isRetrying.value = true;\n        const now = Date.now();\n        const pDelayBy = delay(i); // wrapped\n        const delayBy = isPromise(pDelayBy) ? await pDelayBy : pDelayBy; // unwrap promise\n        if (!isPromise(pDelayBy) || !!delayBy) {\n            if (isNumber(delayBy)) {\n                nextRetry = delayBy;\n            }\n            else if (isDate(delayBy)) {\n                nextRetry = delayBy.getTime();\n            }\n            else {\n                throw new Error(`[useRetry] invalid value received from options.retryDelay '${typeof delayBy}'`);\n            }\n            // if the retry is in the past, means we need to await that amount\n            if (nextRetry < now) {\n                context.nextRetry.value = now + nextRetry;\n            }\n            else {\n                context.nextRetry.value = nextRetry;\n                nextRetry = nextRetry - now;\n            }\n            if (nextRetry > 0) {\n                await promisedTimeout(nextRetry);\n            }\n        }\n        // is cancelled?\n        if (context[CancellationToken].value) {\n            return null;\n        }\n        // is our retry current one?\n        if (retryId !== context[ExecutionId].value) {\n            return result;\n        }\n    } while (i < MAX_RETRIES);\n    return null;\n};\nfunction useRetry(options, factory) {\n    const opt = !options || isFunction(options) ? {} : options;\n    const fn = isFunction(options) ? options : factory;\n    if (!isFunction(options) && !isObject(options)) {\n        throw new Error(\"[useRetry] options needs to be 'object'\");\n    }\n    if (!!fn && !isFunction(fn)) {\n        throw new Error(\"[useRetry] factory needs to be 'function'\");\n    }\n    const isRetrying = ref(false);\n    const nextRetry = ref();\n    const retryErrors = ref([]);\n    const cancellationToken = { value: false };\n    const retryId = { value: 0 };\n    const retryCount = computed(() => retryErrors.value.length);\n    const context = {\n        isRetrying,\n        retryCount,\n        nextRetry,\n        retryErrors,\n        [ExecutionId]: retryId,\n        [CancellationToken]: cancellationToken\n    };\n    const exec = fn\n        ? (...args) => {\n            ++context[ExecutionId].value;\n            return defaultStrategy(opt, context, fn, args);\n        }\n        : (f) => {\n            ++context[ExecutionId].value;\n            return defaultStrategy(opt, context, f, undefined);\n        };\n    const cancel = () => {\n        context.isRetrying.value = false;\n        context.retryErrors.value.push(new Error(\"[useRetry] cancelled\"));\n        context.nextRetry.value = undefined;\n        cancellationToken.value = true;\n    };\n    return {\n        ...context,\n        cancel,\n        exec\n    };\n}\nconst exponentialDelay = retryNumber => {\n    const delay = Math.pow(2, retryNumber) * 100;\n    const randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay\n    return delay + randomSum;\n};\nconst noDelay = () => 0;\n\nfunction usePromiseLazy(fn, throwException = false) {\n    // @ts-ignore\n    return usePromise(fn, {\n        lazy: true,\n        throwException\n    });\n}\n\n// istanbul ignore next\nconst DEVTOOLS_KEY = \n/*#__PURE__*/ Symbol(((process.env.NODE_ENV !== 'production') && \"DEVTOOLS_KEY\") || ``);\n/**\n * provide devtools api instance to the app\n * @param app\n * @param api\n */\nfunction setDevtools(app, api) {\n    if (!isFunction(app.provide)) {\n        console.warn(\"[vue-composable] devtools is not supported for vue 2\");\n        return;\n    }\n    app.provide(DEVTOOLS_KEY, api);\n}\n/**\n * Exposes the internal devtools api instance\n */\nfunction getDevtools() {\n    const empty = {};\n    const devtools = inject(DEVTOOLS_KEY, empty);\n    if (devtools === empty) {\n        console.warn(`[vue-composable] devtools not found, please run app.use(VueComposableDevtools)`);\n        return undefined;\n    }\n    return devtools;\n}\n\nlet apiProxyFactory = undefined;\nasync function pushEventsToApi(api, EventQueue, ApiQueue) {\n    setTimeout(async () => {\n        const priority = [\n            \"addTimelineLayer\",\n            \"addInspector\",\n            \"sendInspectorTree\",\n            \"sendInspectorState\",\n            \"addTimelineEvent\",\n        ];\n        for (const k of priority) {\n            for (const it of ApiQueue.filter((x) => x.type === k)) {\n                // @ts-ignore\n                api[k](...it.args);\n            }\n            await promisedTimeout(20);\n        }\n        new Set(ApiQueue.filter((x) => x.type === \"notifyComponentUpdate\").map((x) => x.args[0])).forEach((x) => api.notifyComponentUpdate(x));\n        // @ts-ignore\n        EventQueue.forEach((x) => api.on[x.type](...x.args));\n        EventQueue.length = 0;\n        ApiQueue.length = 0;\n    }, 100);\n}\n{\n    apiProxyFactory = (promiseApi) => {\n        let api;\n        const EventQueue = [];\n        const ApiQueue = [];\n        const onProxy = new Proxy({}, {\n            get: (target, prop) => {\n                if (api) {\n                    //@ts-expect-error\n                    return api.on[prop];\n                }\n                else if (prop in target) {\n                    // @ts-ignore\n                    return target[prop];\n                }\n                else {\n                    //@ts-ignore\n                    return (target[prop] = (...args) => {\n                        EventQueue.push({\n                            type: prop,\n                            args,\n                        });\n                    });\n                }\n            },\n        });\n        const proxy = new Proxy({\n            on: onProxy,\n        }, {\n            get: (target, prop) => {\n                if (prop === \"on\") {\n                    return target.on;\n                }\n                if (api) {\n                    return api[prop];\n                }\n                if (prop in target) {\n                    // @ts-ignore\n                    return target[prop];\n                }\n                // @ts-ignore\n                return (target[prop] = (...args) => {\n                    ApiQueue.push({\n                        type: prop,\n                        args,\n                    });\n                });\n            },\n        });\n        promiseApi.then((x) => {\n            api = x;\n            pushEventsToApi(api, EventQueue, ApiQueue);\n        });\n        return proxy;\n    };\n}\nvar ProxyApi = apiProxyFactory;\n\nlet setupDevtoolsPlugin = NO_OP;\n// NOTE maybe change this to other flag\nif ((process.env.NODE_ENV !== 'production')) {\n    try {\n        setupDevtoolsPlugin = require(\"@vue/devtools-api\").setupDevtoolsPlugin;\n    }\n    catch { }\n}\nconst UseDevtoolsApp = (app, id = \"vue-composable\", label = \"Vue-composable devtools plugin\") => {\n    const promise = new Promise((res) => {\n        setupDevtoolsPlugin({\n            id,\n            label,\n            app,\n        }, res);\n    });\n    setDevtools(app, ProxyApi(promise));\n};\n\nconst VueComposableDevtools = {\n    install(app, options = {\n        id: \"vue-composable\",\n        label: \"Vue-composable devtools plugin\"\n    }) {\n        return UseDevtoolsApp(app, options.id, options.label);\n    }\n};\n\nfunction useDevtoolsInspector(options, nodeList = []) {\n    const api = getDevtools();\n    const nodes = ref(nodeList);\n    const byId = computed(() => {\n        if (!nodes.value)\n            return new Map();\n        const r = toRaw(nodes.value);\n        const m = new Map();\n        for (const i of r) {\n            m.set(i.id, i);\n        }\n        return m;\n    });\n    if (api) {\n        const id = options.id;\n        api.addInspector(options);\n        // api.on.getInspectorState();\n        api.on.getInspectorTree((payload) => {\n            if (payload.inspectorId != id)\n                return;\n            if (!nodes.value)\n                return;\n            const filter = payload.filter;\n            let m = toRaw(nodes.value);\n            if (payload.filter) {\n                if (options.nodeFilter) {\n                    m = options.nodeFilter(payload.filter, m);\n                }\n                else {\n                    // TODO better filtering, only currently filtering root nodes\n                    m = m.filter((x) => x.id.indexOf(filter) >= 0 || x.label.indexOf(filter) >= 0);\n                }\n            }\n            payload.rootNodes = m;\n        });\n        api.on.getInspectorState((payload) => {\n            if (payload.inspectorId != id)\n                return;\n            const node = byId.value.get(payload.nodeId);\n            if (node) {\n                const s = reactive(node.state); // unwrap\n                payload.state = options.stateFilter ? options.stateFilter(\"\", s) : s;\n            }\n        });\n        watch(nodes, () => {\n            api.sendInspectorTree(id);\n            api.sendInspectorState(id);\n        }, {\n            immediate: true,\n            deep: true,\n        });\n    }\n    return {\n        nodes,\n    };\n}\n\nfunction useDevtoolsTimelineLayer(id, label, color) {\n    const api = getDevtools();\n    let addEvent = NO_OP;\n    let pushEvent = NO_OP;\n    if (api) {\n        api.addTimelineLayer({\n            id,\n            label,\n            color,\n        });\n        addEvent = (event, all) => api.addTimelineEvent({ layerId: id, event, all });\n        pushEvent = (event) => addEvent({ ...event, time: Date.now() });\n    }\n    return {\n        id,\n        addEvent,\n        pushEvent,\n    };\n}\n\nfunction getSetupStateExtra(raw) {\n    if (!raw)\n        return {};\n    // NOTE vue3!\n    const isRef = !!raw.__v_isRef;\n    const isComputed = isRef && !!raw.effect;\n    const isReactive = !!raw.__v_reactive;\n    const objectType = isComputed\n        ? \"Computed\"\n        : isRef\n            ? \"Ref\"\n            : isReactive\n                ? \"Reactive\"\n                : null;\n    return {\n        ...(objectType ? { objectType } : {}),\n        ...(raw.effect ? { raw: raw.effect.raw.toString() } : {}),\n    };\n}\nfunction useDevtoolsComponentState(state, options) {\n    const instance = getCurrentInstance();\n    const api = getDevtools();\n    if (api && instance) {\n        api.on.inspectComponent((payload, ctx) => {\n            if (payload.componentInstance !== instance)\n                return;\n            const [type, multiple] = isObject(options)\n                ? [options.type, options.multiple]\n                : [\"setup\", false];\n            if (isFunction(state)) {\n                state(payload.instanceData, ctx);\n                return;\n            }\n            let data = isArray(state)\n                ? state\n                : Object.keys(state).map((key) => ({\n                    type,\n                    key,\n                    value: unwrap(state[key]),\n                    ...getSetupStateExtra(state[key]),\n                }));\n            if (!multiple) {\n                const inserted = new Set(payload.instanceData.state.map((x) => x.key));\n                data = data.filter((x) => !inserted.has(x.key));\n            }\n            payload.instanceData.state.push(...data);\n        });\n    }\n}\n\nfunction isFetchOptions(v) {\n    return (v &&\n        (isBoolean(v.isJson) ||\n            isBoolean(v.parseImmediate) ||\n            isBoolean(v.unmountCancel)));\n}\nfunction useFetch(options, requestInitOptions) {\n    // TODO move to computeAsync\n    const json = ref(null);\n    const text = ref(\"\");\n    const blob = ref();\n    const jsonError = ref(null);\n    const [isJson, parseImmediate, unmountCancel] = isFetchOptions(options)\n        ? [\n            options.isJson !== false,\n            options.parseImmediate !== false,\n            options.unmountCancel !== false,\n        ]\n        : isFetchOptions(requestInitOptions)\n            ? [\n                requestInitOptions.isJson !== false,\n                requestInitOptions.parseImmediate !== false,\n                requestInitOptions.unmountCancel !== false,\n            ]\n            : [true, true, true];\n    const requestInit = options\n        ? isString(options)\n            ? requestInitOptions\n            : isFetchOptions(options)\n                ? options\n                : isString(options.url)\n                    ? requestInitOptions\n                    : options\n        : undefined;\n    let addTimelineEvent = undefined;\n    let devtoolId = (process.env.NODE_ENV !== 'production')\n        ? isString(options)\n            ? options\n            : options && isString(options.url)\n                ? options.url\n                : \"useFetch\"\n        : undefined;\n    if ((process.env.NODE_ENV !== 'production') && devtoolId) {\n        const layer = useDevtoolsTimelineLayer(`useFetch:${devtoolId}`, devtoolId, 0x32a2bf);\n        addTimelineEvent = (time, request, extra) => layer.addEvent({\n            time,\n            data: {\n                ...request,\n                ...extra,\n            },\n            meta: {},\n        });\n    }\n    const isCancelled = ref(false);\n    const cancelledMessage = ref();\n    let abortController = undefined;\n    const cancel = (message) => {\n        if (!abortController) {\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                if (addTimelineEvent) {\n                    addTimelineEvent(Date.now(), { message }, {\n                        type: \"cancel_error\",\n                        error: \"No request has been made yet\",\n                    });\n                }\n                throw new Error(\"Cannot cancel because no request has been made\");\n            }\n            else {\n                return;\n            }\n        }\n        abortController.abort();\n        isCancelled.value = true;\n        cancelledMessage.value = message;\n        if (addTimelineEvent) {\n            addTimelineEvent(Date.now(), { message }, {\n                type: \"cancel\",\n            });\n        }\n    };\n    const use = usePromise(async (request, init) => {\n        abortController = new AbortController();\n        if (addTimelineEvent) {\n            addTimelineEvent(Date.now(), isString(request) ? { url: request } : request, { type: \"request\", init });\n        }\n        const response = await fetch(request, {\n            signal: abortController.signal,\n            ...requestInit,\n            ...init,\n        });\n        if (addTimelineEvent) {\n            addTimelineEvent(Date.now(), response, {\n                type: \"response\",\n                init,\n                request,\n            });\n        }\n        if (response) {\n            const promises = [\n                // JSON\n                isJson\n                    ? response\n                        .clone()\n                        .json()\n                        .then((x) => (json.value = x))\n                        .catch((x) => {\n                        json.value = null;\n                        jsonError.value = x;\n                    })\n                    : Promise.resolve(),\n                // BLOB\n                response\n                    .clone()\n                    .blob()\n                    .then((x) => {\n                    blob.value = x;\n                }),\n                // TEXT\n                response\n                    .clone()\n                    .text()\n                    .then((x) => {\n                    text.value = x;\n                }),\n            ];\n            if (parseImmediate) {\n                await Promise.all(promises);\n                if (addTimelineEvent) {\n                    addTimelineEvent(Date.now(), {}, {\n                        type: \"parsed\",\n                        json: json.value,\n                        blob: blob.value,\n                        text: text.value,\n                        request,\n                    });\n                }\n            }\n        }\n        return response;\n    }, true);\n    const status = computed(() => (use.result.value && use.result.value.status) || null);\n    const statusText = computed(() => (use.result.value && use.result.value.statusText) || null);\n    // if not options are provided in the config, execute it straight away\n    // NOTE: `false` is passed to the `exec` to prevent the exception to be thrown\n    if (options) {\n        if (isString(options) || isString(options.url)) {\n            use.exec(options, undefined, false);\n        }\n    }\n    if (unmountCancel && getCurrentInstance()) {\n        onUnmounted(() => {\n            if (abortController) {\n                cancel(\"unmounted\");\n            }\n        });\n    }\n    return {\n        ...use,\n        cancel,\n        isCancelled,\n        cancelledMessage,\n        text,\n        blob,\n        json,\n        jsonError,\n        status,\n        statusText,\n    };\n}\n\nfunction useWebSocket(url, protocols) {\n    const supported = isClient && \"WebSocket\" in window;\n    let ws = null;\n    const messageEvent = ref(null);\n    const errorEvent = ref(null);\n    const data = ref(null);\n    const isOpen = ref(false);\n    const isClosed = ref(false);\n    const errored = ref(false);\n    /* istanbul ignore next  */\n    let lastMessage = ((process.env.NODE_ENV !== 'production') && Date.now()) || undefined;\n    let send = NO_OP;\n    let close = NO_OP;\n    if (supported) {\n        ws = new WebSocket(url, protocols);\n        ws.addEventListener(\"message\", x => {\n            messageEvent.value = x;\n            data.value = x.data;\n            // if the messages are to quick, we need to warn\n            /* istanbul ignore else  */\n            if ((process.env.NODE_ENV !== 'production')) {\n                if (Date.now() - lastMessage < 2) {\n                    console.warn('[useWebSocket] message rate is too high, if you are using \"data\" or \"messageEvent\"' +\n                        \" you might not get updated of all the messages.\" +\n                        ' Use \"ws.addEventListener(\"message\", handler)\" instead');\n                }\n                lastMessage = Date.now();\n            }\n        });\n        ws.addEventListener(\"error\", error => {\n            errorEvent.value = error;\n            errored.value = true;\n        });\n        ws.addEventListener(\"close\", () => {\n            isOpen.value = false;\n            isClosed.value = true;\n        });\n        ws.addEventListener(\"open\", () => {\n            isOpen.value = true;\n            isClosed.value = false;\n        });\n        send = (data) => ws.send(data);\n        close = (code, reason) => {\n            ws.close(code, reason);\n        };\n    }\n    return {\n        supported,\n        ws,\n        send,\n        close,\n        messageEvent,\n        errorEvent,\n        data,\n        isOpen,\n        isClosed,\n        errored\n    };\n}\n\nfunction useIntersectionObserver(refEl, refOptions) {\n    const supported = isClient && \"IntersectionObserver\" in window;\n    const wrappedElement = refEl ? wrap(refEl) : undefined;\n    const element = wrappedElement && (isElement(wrappedElement.value) || !wrappedElement.value)\n        ? wrappedElement\n        : undefined;\n    const options = computed(() => refOptions\n        ? unwrap(refOptions)\n        : !element\n            ? unwrap(refEl)\n            : undefined);\n    const elements = ref([]);\n    const isIntersecting = computed(() => elements.value.length > 0 && elements.value.every(x => x.isIntersecting));\n    const handling = (entries) => {\n        elements.value = entries;\n    };\n    let observer = ref();\n    if (supported) {\n        watch(options, options => {\n            if (observer.value) {\n                observer.value.disconnect();\n            }\n            const opts = (options &&\n                options && {\n                root: unwrap(options.root),\n                rootMargin: unwrap(options.rootMargin),\n                threshold: unwrap(options.threshold)\n            }) ||\n                undefined;\n            observer.value = new IntersectionObserver(handling, opts);\n            const targets = elements.value.map(x => x.target);\n            targets.forEach(observer.value.observe);\n        }, { deep: true, immediate: true });\n    }\n    const observe = supported\n        ? (element) => {\n            const e = unwrap(element);\n            observer.value.observe(e);\n        }\n        : NO_OP;\n    const unobserve = supported\n        ? (element) => {\n            const e = unwrap(element);\n            observer.value.unobserve(e);\n        }\n        : NO_OP;\n    const disconnect = () => observer.value.disconnect();\n    // if the element is passed we should add hooks\n    if (element) {\n        // if value is defined it is already being observed\n        // if (!element.value) {\n        onMounted(() => {\n            if (element.value) {\n                observe(element);\n            }\n        });\n        // }\n        onUnmounted(() => {\n            disconnect();\n        });\n    }\n    // // debug is still work in progress, would be nice to provide some\n    // // information about the target\n    // /* istanbul ignore next */\n    // const debug = () => {\n    //   if (elements.value.length === 0) {\n    //     (process.env.NODE_ENV !== 'production') && console.warn('[IntersectionObserver] no elements provided, did you mount the component?')\n    //     return;\n    //   }\n    //   // TODO: add border to the elements\n    // };\n    return {\n        supported,\n        elements,\n        observe,\n        unobserve,\n        disconnect,\n        isIntersecting\n    };\n}\n\nfunction useNetworkInformation() {\n    const connection = isClient\n        ? navigator.connection ||\n            navigator.mozConnection ||\n            navigator.webkitConnection\n        : false;\n    const supported = !!connection;\n    const downlink = ref(0);\n    const downlinkMax = ref(0);\n    const effectiveType = ref(\"none\");\n    const rtt = ref(0);\n    const saveData = ref(false);\n    const type = ref(\"none\");\n    let handler = NO_OP;\n    let remove = NO_OP;\n    /* istanbul ignore else  */\n    if (connection) {\n        handler = () => {\n            downlink.value = connection.downlink;\n            downlinkMax.value = connection.downlinkMax;\n            effectiveType.value = connection.effectiveType;\n            rtt.value = connection.rtt;\n            saveData.value = connection.saveData;\n            type.value = connection.type;\n        };\n        remove = useEvent(connection, \"change\", handler, PASSIVE_EV);\n        handler();\n    }\n    else {\n        /* istanbul ignore else */\n        if ((process.env.NODE_ENV !== 'production')) {\n            console.warn(\"[navigator.connection] not found, networkInformation not available.\");\n        }\n    }\n    return {\n        supported,\n        downlink,\n        downlinkMax,\n        effectiveType,\n        rtt,\n        saveData,\n        type,\n        remove\n    };\n}\n\nlet online = undefined;\nfunction useOnline() {\n    const supported = isClient && \"onLine\" in navigator;\n    // not sure how to test this :/\n    if (!supported) {\n        online = ref(false);\n    }\n    if (!online) {\n        online = ref(navigator.onLine);\n        window.addEventListener(\"offline\", () => (online.value = false), PASSIVE_EV);\n        window.addEventListener(\"online\", () => (online.value = true), PASSIVE_EV);\n    }\n    return {\n        supported,\n        online\n    };\n}\n\nlet visibility = undefined;\nlet hidden = undefined;\nfunction usePageVisibility() {\n    if (!hidden) {\n        hidden = ref(isClient && document.hidden);\n    }\n    if (!visibility) {\n        if (isClient) {\n            visibility = ref(document.visibilityState);\n            document.addEventListener(\"visibilitychange\", () => {\n                visibility.value = document.visibilityState;\n                hidden.value = document.hidden;\n            }, PASSIVE_EV);\n        }\n        else {\n            visibility = ref(\"visible\");\n        }\n    }\n    return {\n        visibility,\n        hidden\n    };\n}\n\nlet language = undefined;\nlet languages = undefined;\nfunction useLanguage() {\n    if (!language) {\n        language = isClient ? ref(navigator.language) : ref(\"\");\n    }\n    if (!languages) {\n        if (isClient) {\n            languages = ref(navigator.languages);\n            const change = () => {\n                language.value = navigator.language;\n                languages.value = navigator.languages;\n            };\n            window.addEventListener(\"languagechange\", change, PASSIVE_EV);\n        }\n        else {\n            languages = ref([]);\n        }\n    }\n    return {\n        language,\n        languages\n    };\n}\n\nfunction useBroadcastChannel(name, onBeforeClose) {\n    const supported = isClient && \"BroadcastChannel\" in self;\n    const data = ref(null);\n    const messageEvent = ref(null);\n    const errorEvent = ref(null);\n    const errored = ref(false);\n    const isClosed = ref(false);\n    let send = NO_OP;\n    let close = NO_OP;\n    let addListener = NO_OP;\n    /* istanbul ignore else  */\n    if (supported) {\n        const bc = new BroadcastChannel(name);\n        bc.addEventListener(\"messageerror\", e => {\n            errorEvent.value = e;\n            errored.value = true;\n        }, PASSIVE_EV);\n        bc.addEventListener(\"message\", ev => {\n            messageEvent.value = ev;\n            data.value = ev.data;\n        }, PASSIVE_EV);\n        send = d => bc.postMessage(d);\n        close = () => {\n            bc.close();\n            isClosed.value = true;\n        };\n        addListener = (cb, o) => {\n            bc.addEventListener(\"message\", cb, o);\n            onUnmounted(() => bc.removeEventListener(\"message\", cb));\n        };\n        onUnmounted(() => {\n            onBeforeClose && onBeforeClose();\n            close();\n        });\n    }\n    else {\n        if ((process.env.NODE_ENV !== 'production')) {\n            console.warn(\"[BroadcastChannel] is not supported\");\n        }\n    }\n    return {\n        supported,\n        data,\n        messageEvent,\n        errorEvent,\n        errored,\n        isClosed,\n        send,\n        close,\n        addListener\n    };\n}\n\nfunction useGeolocation(options) {\n    const supported = isClient && !!navigator.geolocation;\n    // used to check if the execution is lazy\n    const lazy = ref(options ? options.immediate === false : undefined);\n    const error = ref(null);\n    const timestamp = ref(null);\n    const coords = ref(null);\n    const highAccuracy = ref((options && options.enableHighAccuracy) || null);\n    // allow manual control on when the geolocation is requested\n    let refresh = NO_OP;\n    if (supported) {\n        const setPosition = (pos) => {\n            timestamp.value = pos.timestamp;\n            coords.value = pos.coords;\n            error.value = null;\n        };\n        const setError = (err) => {\n            timestamp.value = Date.now();\n            coords.value = null;\n            error.value = err;\n        };\n        const clearWatch = () => lazy.value !== true &&\n            watchId &&\n            navigator.geolocation.clearWatch(watchId);\n        let _currentPositionRefresh = () => navigator.geolocation.getCurrentPosition(setPosition, setError, options);\n        if (lazy.value) {\n            refresh = () => {\n                if (lazy.value) {\n                    lazy.value = false;\n                }\n                else {\n                    _currentPositionRefresh();\n                }\n            };\n        }\n        else {\n            // NOTE probably useless??\n            refresh = _currentPositionRefresh;\n        }\n        let watchId = 0;\n        onMounted(() => watch([highAccuracy, lazy], (a) => {\n            clearWatch();\n            const enableHighAccuracy = isBoolean(a[0])\n                ? a[0]\n                : options\n                    ? options.enableHighAccuracy\n                    : undefined;\n            watchId = navigator.geolocation.watchPosition(setPosition, setError, options\n                ? { ...options, enableHighAccuracy }\n                : { enableHighAccuracy });\n        }, {\n            immediate: !lazy.value,\n        }));\n        onUnmounted(clearWatch);\n    }\n    return {\n        supported,\n        refresh,\n        error,\n        timestamp,\n        coords,\n        highAccuracy,\n    };\n}\n\n/**\n * Gets the current value of the given CSS variable name for the given element.\n *\n * @param element The element to get the variable for.\n * @param name The CSS variable name.\n */\nfunction getCssVariableFor(element, name) {\n    const result = getComputedStyle(element).getPropertyValue(name);\n    return result ? result.trim() : null;\n}\n/**\n * Sets the value of the given CSS variable for the given element.\n *\n * @param element The element to set the variable for.\n * @param name The CSS variable name without dashes.\n * @param value The CSS variable value.\n */\nfunction setCssVariableFor(element, name, value) {\n    element.style.setProperty(name, value);\n}\nconst defaultOptions = {\n    attributes: true,\n    childList: true,\n    subtree: true\n};\nconst sanitizeCssVarName = (name) => {\n    if (name.length <= 2 || name[0] !== \"-\" || name[1] !== \"-\") {\n        return `--${name}`;\n    }\n    return name;\n};\nfunction useCssVariables(variables, elementOrOptions, optionsConfig) {\n    const supported = isClient && \"MutationObserver\" in self;\n    const [element, options] = isRef(elementOrOptions) || isElement(elementOrOptions)\n        ? [elementOrOptions, optionsConfig || defaultOptions]\n        : [\n            (supported && document.documentElement) || {},\n            elementOrOptions || defaultOptions\n        ];\n    // Reactive property to tell if the observer is listening\n    const observing = ref(true);\n    // Stores the results by reference.\n    const result = {};\n    // If the element is ref, we should only update the variable on mount\n    const updateValues = [];\n    // extract name\n    const defEntries = Object.entries(variables).map((x) => {\n        const [name, value] = isString(x[1]) ? [x[1]] : [x[1].name, x[1].value];\n        if (value) {\n            updateValues.push(() => setCssVariableFor(unwrap(element), name, unwrap(value)));\n            // if is ref, use provided ref instead\n            result[x[0]] = wrap(value);\n        }\n        return [x[0], sanitizeCssVarName(name)];\n    });\n    for (let i = 0; i < defEntries.length; i++) {\n        const [key, name] = defEntries[i];\n        if (!result[key]) {\n            // if is ref set null, onMount we will update\n            result[key] = ref((isRef(element) && !element.value) || !supported\n                ? null\n                : getCssVariableFor(unwrap(element), name));\n        }\n        if (supported) {\n            // keep track of changes\n            watch([result[key], wrap(element)], (val) => {\n                if (!observing)\n                    return;\n                // don't force if the current value is the same as the given one\n                // or if the given one is empty\n                if (val[1] && val[0] !== getCssVariableFor(val[1], name)) {\n                    setCssVariableFor(val[1], name, val[0]);\n                }\n            }, { immediate: !isRef(element) });\n        }\n    }\n    if (!supported) {\n        return {\n            ...result,\n            stop: NO_OP,\n            resume: NO_OP,\n            supported,\n            observing\n        };\n    }\n    const update = () => {\n        // Each time an observation has been made,\n        // we look up for each CSS variable and update their values.\n        for (let i = 0; i < defEntries.length; i++) {\n            const [key, value] = defEntries[i];\n            result[key].value = getCssVariableFor(unwrap(element), value);\n        }\n    };\n    // Sets up the observer.\n    const observer = new MutationObserver(update);\n    // Sets the `stop` method.\n    const stop = () => {\n        observer.disconnect();\n        observing.value = false;\n    };\n    // Sets the `start` method.\n    const resume = () => {\n        // if it was stopped we will update the variables to the current value\n        if (!observing.value) {\n            update();\n        }\n        observer.observe(unwrap(element), options);\n        observing.value = true;\n    };\n    // Stops on destroy\n    onUnmounted(stop);\n    if (isRef(element)) {\n        onMounted(() => {\n            updateValues.forEach(x => x());\n            watch(element, (n, o) => {\n                if (o) {\n                    stop();\n                }\n                if (n) {\n                    resume();\n                }\n            });\n        });\n    }\n    else if (isClient || element) {\n        updateValues.forEach(x => x());\n        // Starts observe\n        resume();\n    }\n    return {\n        ...result,\n        supported,\n        resume,\n        stop,\n        observing\n    };\n}\n\n// from https://github.com/dai-shi/react-hooks-worker/blob/1e842ad15c558fc04dd7339a62aaa43f46d1c7cd/src/exposeWorker.js\n// export function exposeWorker(func: (...args: any[]) => any): void;\nfunction exposeWorker(func) {\n    this.onmessage = async (e) => {\n        const r = func(e.data);\n        if (r === undefined) {\n            // istanbul ignore else\n            if ((process.env.NODE_ENV !== 'production')) {\n                console.warn(`[exposeWorker] returned \\`${r}\\`, this might cause unexpected behaviour`);\n            }\n            this.postMessage(r);\n        }\n        else if (r === null) {\n            this.postMessage(r);\n        }\n        else if (isArray(r)) {\n            this.postMessage(r);\n        }\n        else if (r[Symbol.asyncIterator]) {\n            for await (const i of r)\n                this.postMessage(i);\n        }\n        else if (r[Symbol.iterator]) {\n            for (const i of r)\n                this.postMessage(i);\n        }\n        else {\n            this.postMessage(await r);\n        }\n    };\n}\nfunction useWorker(stringUrl, args, options) {\n    const supported = isClient && \"Worker\" in self;\n    const errorEvent = ref();\n    const data = ref();\n    const terminated = ref(!supported);\n    const errored = ref(!supported);\n    if (!supported) {\n        terminated.value = true;\n        return {\n            worker: undefined,\n            data,\n            postMessage: NO_OP,\n            terminate: NO_OP,\n            errorEvent,\n            errored,\n            terminated\n        };\n    }\n    const worker = new Worker(stringUrl, options);\n    /* istanbul ignore next  */\n    let lastMessage = ((process.env.NODE_ENV !== 'production') && Date.now() - 20) || undefined;\n    const postMessage = data => worker.postMessage(data);\n    function terminate() {\n        worker.terminate();\n        terminated.value = true;\n    }\n    worker.addEventListener(\"message\", x => {\n        data.value = x.data;\n        // if the messages are to quick, we need to warn\n        /* istanbul ignore else  */\n        if ((process.env.NODE_ENV !== 'production')) {\n            if (Date.now() - lastMessage < 2) {\n                console.warn(\"[useWorker] message rate is too high, you might not get updated of all the messages.\");\n            }\n            lastMessage = Date.now();\n        }\n    }, PASSIVE_EV);\n    worker.addEventListener(\"error\", error => {\n        errorEvent.value = error;\n        errored.value = true;\n    }, PASSIVE_EV);\n    onUnmounted(terminate);\n    if (args) {\n        postMessage(args);\n    }\n    return {\n        worker,\n        data,\n        postMessage,\n        terminate,\n        errorEvent,\n        errored,\n        terminated\n    };\n}\n\n/**\n * Invokes the native sharing mechanism of the device\n * [compatibility](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share)\n * @param data - if provided it will automatically try to share it\n */\nfunction useShare(data) {\n    const supported = isClient && \"share\" in navigator;\n    let share = () => Promise.resolve(false);\n    let canShare = FALSE_OP;\n    let shared = ref(false);\n    let cancelled = ref(false);\n    if (supported) {\n        share = data => {\n            shared.value = false;\n            cancelled.value = false;\n            return navigator\n                .share(data)\n                .then(x => {\n                shared.value = true;\n                return x;\n            })\n                .catch(e => {\n                shared.value = false;\n                cancelled.value = true;\n                return false;\n            });\n        };\n        canShare = data => navigator.canShare(data);\n        if (data) {\n            if (canShare(data)) {\n                share(data);\n            }\n        }\n    }\n    return {\n        supported,\n        share,\n        canShare,\n        shared,\n        cancelled\n    };\n}\n\nfunction useClipboard() {\n    const supported = isClient && \"clipboard\" in navigator;\n    const text = ref();\n    const data = ref();\n    const writeText = (data) => {\n        text.value = data;\n        if (!supported)\n            return Promise.resolve();\n        // TOOD check for permissions\n        return navigator.clipboard.writeText(data);\n    };\n    const write = (data) => {\n        if (!supported)\n            return Promise.resolve();\n        // TOOD check for permissions\n        // @ts-ignore\n        return navigator.clipboard.write(data);\n    };\n    let readText = () => Promise.resolve(undefined);\n    // @ts-ignore\n    let read = readText;\n    if (supported) {\n        let updating = false;\n        const update = () => readText().then((x) => (text.value = x));\n        [\"copy\", \"cut\", \"focus\"].map((event) => useEvent(window, event, () => update()));\n        readText = () => navigator.clipboard.readText().then((x) => {\n            try {\n                updating = true;\n                return (text.value = x);\n            }\n            finally {\n                // case of a sync watch it might throw\n                updating = false;\n            }\n        });\n        // @ts-ignore this should work\n        read = () => navigator.clipboard.read().then((x) => (data.value = x));\n        watch(text, debounce((s) => {\n            if (updating || !isString(s))\n                return;\n            writeText(s);\n        }, 100));\n    }\n    return {\n        supported,\n        text,\n        data,\n        writeText,\n        readText,\n        write,\n        read,\n    };\n}\n\n/**\n * @param fn setTimeout callback\n * @param delay If this parameter is omitted, a value of 0 is used\n * (https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)\n */\nfunction useTimeout(fn, delay = 0) {\n    let ready = ref(false);\n    const timeoutId = setTimeout(() => {\n        ready.value = true;\n        fn();\n    }, delay);\n    const cancel = () => {\n        ready.value = null;\n        clearTimeout(timeoutId);\n    };\n    onUnmounted(cancel);\n    return {\n        ready,\n        cancel,\n    };\n}\n\nconst inlineWorkExecution = (f) => function (e) {\n    const args = e.data || [];\n    return new Promise((res) => {\n        try {\n            Promise.resolve(f.apply(f, args))\n                // @ts-ignore\n                .then((x) => res(postMessage([true, x])))\n                // @ts-ignore\n                .catch((x) => res(postMessage([false, x])));\n        }\n        catch (e) {\n            // @ts-ignore\n            res(postMessage([false, e]));\n        }\n    });\n};\nfunction createBlobUrl(fn, dependencies) {\n    const scripts = dependencies.length > 0\n        ? `importScripts(\"${dependencies.join('\",\"')}\");`\n        : \"\";\n    const blobScript = [\n        scripts,\n        \"onmessage=\",\n        `(${inlineWorkExecution.toString()})(${fn.toString()})`,\n    ];\n    const blob = new Blob(blobScript, { type: \"text/javascript\" });\n    return URL.createObjectURL(blob);\n}\nfunction useWorkerFunction(fn, options) {\n    const supported = isClient && \"Worker\" in self;\n    // reactive\n    const dependencies = computed(() => (options && unwrap(options.dependencies)) || []);\n    const timeoutRef = computed(() => options && unwrap(options.timeout));\n    if (!supported) {\n        return useCancellablePromise(fn, { lazy: true, throwException: true });\n    }\n    const promise = useCancellablePromise((...args) => new Promise((res, rej) => {\n        const blobUrl = createBlobUrl(fn, dependencies.value);\n        const worker = new Worker(blobUrl);\n        let timeoutId = -1;\n        const timeout = timeoutRef.value;\n        const terminate = () => {\n            worker.terminate();\n            URL.revokeObjectURL(blobUrl);\n            clearTimeout(timeoutId);\n            removeWatch();\n        };\n        // if the last argument is ref(false) we should also track it\n        const watchCancel = args.length === fn.length + 1 &&\n            isRef(args[args.length - 1]) &&\n            args[args.length - 1].value === false\n            ? computed(() => promise.cancelled.value || args[args.length - 1].value)\n            : promise.cancelled;\n        const removeWatch = watchCancel\n            ? watch(watchCancel, () => {\n                terminate();\n                res(undefined);\n            }, { immediate: false })\n            : NO_OP;\n        worker.addEventListener(\"message\", (e) => {\n            if (e.data[0]) {\n                res(e.data[1]);\n            }\n            else {\n                rej(e.data[1]);\n            }\n            terminate();\n        }, PASSIVE_EV);\n        worker.addEventListener(\"error\", (e) => {\n            terminate();\n            rej(e);\n        }, PASSIVE_EV);\n        worker.postMessage([...args]);\n        if (timeout) {\n            timeoutId = setTimeout(() => {\n                promise.cancel(`[WebWorker] timeout after ${timeout}ms`);\n            }, timeout);\n        }\n    }), {\n        lazy: true,\n        throwException: true,\n    });\n    return promise;\n}\n\nfunction useMatchMedia(query) {\n    const supported = isClient ? \"matchMedia\" in window : false;\n    let mediaQueryList = undefined;\n    let matches = undefined;\n    let remove = NO_OP;\n    if (supported) {\n        mediaQueryList = ref(matchMedia(query));\n        matches = ref(mediaQueryList.value.matches);\n        const process = (e) => {\n            matches.value = e.matches;\n        };\n        mediaQueryList.value.addEventListener(\"change\", process, PASSIVE_EV);\n        const remove = () => mediaQueryList.value.removeEventListener(\"change\", process);\n        onUnmounted(remove);\n    }\n    else {\n        /* istanbul ignore else */\n        if ((process.env.NODE_ENV !== 'production')) {\n            console.warn(\"[matchMedia] not supported\");\n        }\n        mediaQueryList = ref({});\n        matches = ref(false);\n    }\n    return {\n        supported,\n        mediaQueryList,\n        matches,\n        remove\n    };\n}\n\nfunction useSharedRef(name, defaultValue) {\n    const { addListener, send, close, supported } = useBroadcastChannel(name, () => disconnect());\n    const id = Date.now();\n    const master = ref(false);\n    const mind = ref(0 /* HIVE */);\n    const editable = computed(() => mind.value === 1 /* MASTER */ ? master.value : true);\n    // who's listening to this broadcast\n    const targets = ref([]);\n    const data = ref(defaultValue);\n    // if the state was updated by an event it sets to true\n    let updateState = false;\n    let masterId = undefined;\n    send({ type: 0 /* INIT */ });\n    const ping = () => send({ type: 5 /* PING */, id });\n    const disconnect = () => {\n        if (targets.value.length === 0)\n            return;\n        if (master.value) {\n            send({\n                type: 3 /* SET_MIND */,\n                mind: 1 /* MASTER */,\n                id: Math.min(...targets.value),\n            });\n        }\n        send({\n            type: 4 /* LEAVE */,\n            id,\n        });\n    };\n    const setMind = (t) => {\n        switch (t) {\n            case 1 /* MASTER */: {\n                master.value = true;\n                break;\n            }\n            case 0 /* HIVE */: {\n                master.value = false;\n                break;\n            }\n        }\n        mind.value = t;\n        send({\n            type: 3 /* SET_MIND */,\n            id: id,\n            mind: mind.value,\n        });\n    };\n    addListener((e) => {\n        switch (e.data.type) {\n            case 0 /* INIT */: {\n                send({\n                    type: 2 /* UPDATE */,\n                    value: data.value,\n                    mind: mind.value,\n                });\n                break;\n            }\n            case 4 /* LEAVE */: {\n                const index = targets.value.indexOf(e.data.id);\n                if (index >= 0) {\n                    targets.value.splice(index, 1);\n                }\n                // if master disconnects\n                if (masterId === e.data.id && targets.value.length > 0) {\n                    send({\n                        type: 3 /* SET_MIND */,\n                        mind: 1 /* MASTER */,\n                        id: Math.min(id, ...targets.value),\n                    });\n                }\n                break;\n            }\n            case 2 /* UPDATE */: {\n                updateState = true;\n                data.value = e.data.value;\n                mind.value = e.data.mind;\n                break;\n            }\n            case 3 /* SET_MIND */: {\n                mind.value = e.data.mind;\n                masterId =\n                    (e.data.mind === 1 /* MASTER */ && e.data.id) || undefined;\n                master.value = masterId === id;\n                if (master.value) {\n                    targets.value = [];\n                    ping();\n                }\n                break;\n            }\n            case 5 /* PING */: {\n                targets.value = [e.data.id];\n                send({\n                    type: 6 /* PONG */,\n                    id,\n                });\n                break;\n            }\n            case 6 /* PONG */: {\n                targets.value.push(e.data.id);\n                break;\n            }\n        }\n    }, PASSIVE_EV);\n    ping();\n    watch(data, (v, o) => {\n        if (updateState) {\n            updateState = false;\n            return;\n        }\n        // mind is set to MASTER and we are not master, we shouldn't update!\n        if (mind.value === 1 /* MASTER */ && master.value === false) {\n            updateState = true;\n            data.value = o;\n            return;\n        }\n        send({\n            type: 2 /* UPDATE */,\n            mind: mind.value,\n            value: isObject(v) ? { ...v } : v,\n        });\n        updateState = false;\n    }, { deep: true, immediate: false });\n    if (isClient) {\n        window.addEventListener(\"unload\", disconnect, PASSIVE_EV);\n    }\n    onUnmounted(() => {\n        disconnect();\n        close();\n    });\n    return {\n        supported,\n        id,\n        data,\n        master,\n        mind,\n        editable,\n        targets,\n        ping,\n        setMind,\n        addListener: addListener,\n    };\n}\nlet shared = undefined;\nfunction refShared(defaultValue, id) {\n    const vm = getCurrentInstance();\n    const name = id\n        ? id\n        : vm.vnode.scopeId; // TODO test this :/ NOTE @vue/runtime-core might be different\n    if (!name) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            console.warn(\"[refShared] please assign an id, returning `ref`\");\n        }\n        return ref(defaultValue);\n    }\n    /* istanbul ignore else  */\n    if ((process.env.NODE_ENV !== 'production')) {\n        if (!shared) {\n            shared = new Set();\n        }\n        if (shared.has(name)) {\n            console.warn(\"[refShared] You can only have one refShared per component, if you need more please assign pass an id refShared(defaultValue, id)\");\n        }\n        shared.add(name);\n    }\n    const { data, supported } = useSharedRef(name, defaultValue);\n    /* istanbul ignore next  */\n    if ((process.env.NODE_ENV !== 'production')) {\n        if (!supported) {\n            console.warn(\"[refShared] is dependent of BroadcastChannel\");\n        }\n    }\n    return data;\n}\n\nconst SCROLL_LOCK_CLASS = \"no-scroll\";\nfunction useLockScroll(selectorElements, classOptions) {\n    const elements = (isString(selectorElements)\n        ? ref([]) // it will be resolved when mounted\n        : isArray(unref(selectorElements))\n            ? wrap(selectorElements)\n            : wrap([selectorElements]));\n    const options = isString(classOptions)\n        ? { lockedClass: classOptions, auto: true }\n        : classOptions || { auto: true };\n    if (!options.lockedClass) {\n        options.lockedClass = SCROLL_LOCK_CLASS;\n    }\n    const locked = ref(false);\n    // NOTE issues on Vue3 because of the `watch.deep`, we wrap all elements\n    const tracked = computed(() => elements.value.map(x => ref(x)));\n    const remove = watch([locked, tracked], ([l, els], [oldLocked, oldElements]) => {\n        for (const refEl of els) {\n            const el = unwrap(refEl);\n            // istanbul ignore else\n            if (options.lockedClass) {\n                // istanbul ignore else\n                if (!el) {\n                    // istanbul ignore else\n                    if ((process.env.NODE_ENV !== 'production')) {\n                        console.warn(\"[useLockScroll] element is undefined\");\n                    }\n                    return;\n                }\n                el.classList.toggle(options.lockedClass, l);\n            }\n            if (options.onChange) {\n                if (oldLocked !== l || !oldElements.find(x => unwrap(x) === el))\n                    options.onChange(el, l);\n            }\n        }\n    }, { flush: \"sync\", deep: false });\n    const lock = () => (locked.value = true);\n    const unlock = () => (locked.value = false);\n    if (isString(selectorElements)) {\n        onMounted(() => (elements.value = Array.from(document.querySelectorAll(selectorElements))));\n    }\n    if (options.auto !== false) {\n        onMounted(lock);\n        onActivated(lock);\n        onDeactivated(unlock);\n        onBeforeUnmount(unlock);\n    }\n    return {\n        locked,\n        lock,\n        unlock,\n        remove\n    };\n}\n\nfunction useVModel(props, name) {\n    const instance = getCurrentInstance();\n    if (!instance) {\n        throw new Error(\"useVModel must be called from the setup or lifecycle hook methods.\");\n    }\n    return computed({\n        get() {\n            return props[name];\n        },\n        set(v) {\n            // @ts-ignore when building v2 the instance doesn't have `emit`\n            instance.emit(`update:${name}`, v);\n        },\n    });\n}\n\nfunction injectFactory(key, defaultValueFactory) {\n    return inject(key, defaultValueFactory, true);\n}\n\nfunction useInterval(callback, ms, ...args) {\n    let intervalId = undefined;\n    const start = (_ms, ..._args) => {\n        remove();\n        if (!_ms && !ms) {\n            return;\n        }\n        const m = (_ms || ms);\n        return (intervalId = setInterval(callback, m, ...(_args && _args.length ? _args : args)));\n    };\n    const remove = () => {\n        if (!intervalId)\n            return;\n        clearInterval(intervalId);\n        intervalId = undefined;\n    };\n    if (isNumber(ms)) {\n        start();\n    }\n    onUnmounted(remove);\n    return { remove, start };\n}\n// TODO move this:  type checkings\n// useInterval((x: number) => {}).start();\n// useInterval((x: number) => {}, 100, 1).start();\n// useInterval(() => {}).start();\n\nfunction refDebounced(value, delay) {\n    let [v, d] = arguments.length === 1 && isNumber(value) && typeof delay === \"undefined\"\n        ? [ref(), value]\n        : [ref(value), delay];\n    return customRef((track, trigger) => ({\n        get() {\n            track();\n            return v.value;\n        },\n        set: debounce(val => {\n            v.value = val;\n            trigger();\n        }, d)\n    }));\n}\n\nfunction intlDateFormatExtractArguments(localesOptions, opts) {\n    const wrappedOpts = wrap(opts);\n    const wrappedLocalesOptions = wrap(localesOptions);\n    return isObject(wrappedOpts.value) || isRef(opts)\n        ? [\n            wrappedLocalesOptions.value !== undefined\n                ? wrappedLocalesOptions\n                : undefined,\n            wrappedOpts,\n        ]\n        : isObject(wrappedLocalesOptions.value) &&\n            !isArray(wrappedLocalesOptions.value) &&\n            !isString(wrappedLocalesOptions.value)\n            ? [undefined, wrappedLocalesOptions]\n            : [\n                wrappedLocalesOptions.value\n                    ? wrappedLocalesOptions\n                    : undefined,\n                undefined,\n            ];\n}\n\nfunction useIntlDateTimeFormat(localesOptions, opts) {\n    const [locales, options] = intlDateFormatExtractArguments(localesOptions, opts);\n    const formatter = computed(() => new Intl.DateTimeFormat(unwrap(locales), unwrap(options)));\n    const formatString = (value, overrideOpts, overrideLocale) => {\n        const f = overrideOpts || overrideLocale\n            ? new Intl.DateTimeFormat(unwrap(overrideLocale) ||\n                unwrap(locales), { ...unwrap(options), ...unwrap(overrideOpts) })\n            : formatter.value;\n        const v = unwrap(value);\n        return f.format(isString(v) ? new Date(v) : v);\n    };\n    const format = (value, overrideOpts, overrideLocale) => computed(() => formatString(value, overrideOpts, overrideLocale));\n    return {\n        format,\n        formatString,\n        formatter,\n    };\n}\n\nfunction useIntlNumberFormat(localesOptions, opts) {\n    const [locales, options] = intlDateFormatExtractArguments(localesOptions, opts);\n    const formatter = computed(() => new Intl.NumberFormat(unwrap(locales), unwrap(options)));\n    const formatString = (value, overrideOpts, overrideLocale) => {\n        const f = overrideOpts || overrideLocale\n            ? new Intl.NumberFormat(unwrap(overrideLocale) ||\n                unwrap(locales), { ...unwrap(options), ...unwrap(overrideOpts) })\n            : formatter.value;\n        return f.format(unwrap(value));\n    };\n    const format = (value, overrideOpts, overrideLocale) => computed(() => formatString(value, overrideOpts, overrideLocale));\n    return {\n        format,\n        formatString,\n        formatter\n    };\n}\n\nfunction useCurrencyFormat(currencyCodeOptions, localesOptions, opts) {\n    const unwrapCodeOptions = unwrap(currencyCodeOptions);\n    const hasCurrency = !isObject(unwrapCodeOptions);\n    const currencyCode = hasCurrency\n        ? currencyCodeOptions\n        : computed(() => {\n            const o = unwrap(currencyCodeOptions);\n            return o.currency;\n        });\n    const [locales, argOptions] = intlDateFormatExtractArguments(localesOptions, hasCurrency\n        ? opts\n        : currencyCodeOptions);\n    const options = computed(() => {\n        const opts = unwrap(argOptions) || {};\n        const currency = unwrap(currencyCode) || opts.currency;\n        return {\n            style: \"currency\",\n            ...opts,\n            currency\n        };\n    });\n    const numberFormat = useIntlNumberFormat(locales);\n    const formatString = (amount, currency, display, opts, overrideLocale) => {\n        const o = { ...options.value, ...unwrap(opts) };\n        const c = unwrap(currency) || o.currency;\n        const d = unwrap(display) || o.currencyDisplay;\n        // istanbul ignore else\n        if ((process.env.NODE_ENV !== 'production')) {\n            if (!c) {\n                console.error(\"[useCurrencyFormat] No currency provided.\");\n                return \"\";\n            }\n            if (o.style !== \"currency\") {\n                console.warn(\"[useCurrencyFormat] invalid style passed in options, please leave it undefined.\");\n            }\n        }\n        return numberFormat.formatString(amount, {\n            ...o,\n            currency: c,\n            currencyDisplay: d\n        }, overrideLocale);\n    };\n    const format = (amount, currency, display, opts, overrideLocale) => {\n        return computed(() => formatString(amount, currency, display, opts, overrideLocale));\n    };\n    return {\n        format,\n        formatString\n    };\n}\n\nfunction getBreakpointWidth(bp) {\n    if (!bp)\n        return undefined;\n    if (isNumber(bp))\n        return bp;\n    return isValidWidthBreakpoint(bp);\n}\nconst isValidWidthBreakpoint = (bp) => {\n    const m = bp.match(/^(\\d+)px$/);\n    if (m) {\n        return +m[1];\n    }\n    return undefined;\n};\nfunction useBreakpoint(breakpoints) {\n    const result = {};\n    const map = new Map();\n    const current = ref();\n    let sorted = [];\n    const removeMedia = [];\n    for (const key in breakpoints) {\n        const bp = breakpoints[key];\n        const width = getBreakpointWidth(bp);\n        if (width !== undefined) {\n            const r = ref(false);\n            result[key] = r;\n            map.set(width, {\n                name: key,\n                valid: r,\n            });\n            sorted.push(width);\n        }\n        else {\n            const { matches, remove } = useMatchMedia(bp);\n            result[key] = matches;\n            removeMedia.push(remove);\n        }\n    }\n    sorted = sorted.sort((a, b) => b - a);\n    const resize = isClient\n        ? () => {\n            const width = window.innerWidth;\n            let c = undefined;\n            for (let i = 0; i < sorted.length; i++) {\n                const bp = sorted[i];\n                const r = map.get(bp);\n                r.valid.value = width >= bp;\n                if (width >= bp && c === undefined) {\n                    c = r.name;\n                }\n            }\n            current.value = c;\n        }\n        : NO_OP;\n    const processResize = useDebounce(resize, 10);\n    const remove = isClient\n        ? () => window.removeEventListener(\"resize\", processResize)\n        : NO_OP;\n    if (isClient) {\n        onMounted(() => {\n            resize();\n            window.addEventListener(\"resize\", processResize, PASSIVE_EV);\n        });\n        onUnmounted(() => {\n            remove();\n            removeMedia.forEach((x) => x());\n        });\n    }\n    return {\n        ...result,\n        remove,\n        current,\n    };\n}\n\nfunction useBreakpointChrome() {\n    return useBreakpoint({\n        mobileS: 320,\n        mobileM: 375,\n        mobileL: 425,\n        tablet: 768,\n        laptop: 1024,\n        laptopL: 1440,\n        desktop4K: 2560\n    });\n}\n\n// istanbul ignore next\nconst BREAKPOINT_TAILWIND_KEY = Symbol(((process.env.NODE_ENV !== 'production') && \"TAILWIND_BREAKPOINTS\") || ``);\nconst defaultTailwindBreakpoint = {\n    sm: 640,\n    md: 768,\n    lg: 1024,\n    xl: 1280,\n};\nfunction isTailwind(t) {\n    return isObject(t) && isObject(t.theme) && isObject(t.theme.screens);\n}\nfunction isRawScreen(t) {\n    return isObject(t) && isString(t.raw);\n}\nfunction isRangeScreen(t) {\n    if (!isObject(t))\n        return false;\n    return (isString(t.min) || isString(t.max) || isNumber(t.min) || isNumber(t.max));\n}\n/**\n * Sanitize width value, if number is passed it will append `px`\n * @param s width value\n */\nfunction sanitizeWidth(s) {\n    return isNumber(s) ? s + \"px\" : s;\n}\nfunction screenRangeToBreakpoint(s) {\n    if (!isRangeScreen(s)) {\n        // istanbul ignore else\n        if ((process.env.NODE_ENV !== 'production')) {\n            console.warn(\"[useBreakpointTailwind] screen range provided is not valid\");\n        }\n        return \"\";\n    }\n    const condition = [\n        s.max && `max-width: ${sanitizeWidth(s.max)}`,\n        s.min && `min-width: ${sanitizeWidth(s.min)}`,\n    ]\n        .filter(Boolean)\n        .join(\" and \");\n    return `(${condition})`;\n}\nfunction screenToBreakpoint(s) {\n    const conditions = [];\n    if (isArray(s)) {\n        const bks = s.map(screenToBreakpoint);\n        for (let i = 0; i < bks.length; i++) {\n            const b = bks[i];\n            conditions.push(...b);\n        }\n    }\n    else if (isRawScreen(s)) {\n        conditions.push(s.raw);\n    }\n    else if (isRangeScreen(s)) {\n        conditions.push(screenRangeToBreakpoint(s));\n    }\n    else if (isString(s) || isNumber(s)) {\n        conditions.push(`(min-width: ${sanitizeWidth(s)})`);\n    }\n    else {\n        // istanbul ignore else\n        if ((process.env.NODE_ENV !== 'production')) {\n            console.warn(\"[useBreakpointTailwind] unknown type used for the breakpoint`\");\n        }\n    }\n    return conditions;\n}\nfunction setBreakpointTailwindCSS(breakpoints) {\n    const bk = isTailwind(breakpoints) ? breakpoints.theme.screens : breakpoints;\n    if (isTailwind(breakpoints)) {\n        for (const k in bk) {\n            // istanbul ignore else\n            if (bk.hasOwnProperty(k)) {\n                const v = bk[k];\n                if (isObject(v)) {\n                    bk[k] = screenToBreakpoint(bk[k]).join(\" or \");\n                }\n                else if (isString(v)) {\n                    if (!v.endsWith(\"px\")) {\n                        bk[k] = screenToBreakpoint(bk[k]).join(\" or \");\n                    }\n                }\n            }\n        }\n    }\n    const bp = useBreakpoint(bk);\n    provide(BREAKPOINT_TAILWIND_KEY, bp);\n    return bp;\n}\nfunction useBreakpointTailwindCSS(config) {\n    return injectFactory(BREAKPOINT_TAILWIND_KEY, () => setBreakpointTailwindCSS(config || defaultTailwindBreakpoint));\n}\n\nconst STORAGE_TEST_KEY = (process.env.NODE_ENV !== 'production') ? \"__storage_test__\" : \":$\";\n/* istanbul ignore next */\nfunction isQuotaExceededError(e, storage) {\n    return (e instanceof DOMException &&\n        // everything except Firefox\n        (e.code === 22 ||\n            // Firefox\n            e.code === 1014 ||\n            // test name field too, because code might not be present\n            // everything except Firefox\n            e.name === \"QuotaExceededError\" ||\n            // Firefox\n            e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") &&\n        // acknowledge QuotaExceededError only if there's something already stored\n        ((storage && storage.length !== 0) || false));\n}\n// based on https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API\nfunction storageAvailable(storage) {\n    try {\n        if (!storage) {\n            return false;\n        }\n        const x = STORAGE_TEST_KEY;\n        storage.setItem(x, x);\n        storage.removeItem(x);\n        return true;\n    }\n    catch (e) {\n        return isQuotaExceededError(e, storage);\n    }\n}\nfunction safeParse(serializer, value) {\n    try {\n        return serializer.parse(value);\n    }\n    catch {\n        return value;\n    }\n}\nlet storageMap = undefined;\nfunction useWebStorage(type, serializer = JSON, ms = 10) {\n    const storage = isClient ? window[type] : undefined;\n    const supported = storageAvailable(storage);\n    const remove = () => storageMap.delete(type);\n    if (!storageMap) {\n        storageMap = new Map();\n        if (isClient) {\n            window.addEventListener(\"storage\", (e) => {\n                if (e.newValue === e.oldValue) {\n                    return;\n                }\n                let webStore = storageMap.get(\"localStorage\");\n                if (e.storageArea === window.localStorage) {\n                    webStore = storageMap.get(\"localStorage\");\n                }\n                else {\n                    webStore = storageMap.get(\"sessionStorage\");\n                }\n                if (webStore && Object.keys(webStore.$syncKeys).length > 0) {\n                    if (e.key === null) {\n                        webStore.clear();\n                    }\n                    else if (webStore.$syncKeys[e.key]) {\n                        if (e.newValue === null) {\n                            webStore.removeItem(e.key);\n                        }\n                        else {\n                            webStore.updateItem(e.key, e.newValue);\n                        }\n                    }\n                }\n            });\n        }\n    }\n    let store = storageMap.get(type);\n    let quotaError;\n    if (supported && storage) {\n        if (!store) {\n            quotaError = ref(false);\n            store = {\n                $refMap: new Map(),\n                $watchHandlers: new Map(),\n                $syncKeys: {},\n                $quotaError: quotaError,\n                key: storage.key,\n                length: storage.length,\n                setSync(key, sync) {\n                    if (sync) {\n                        this.$syncKeys[key] = true;\n                    }\n                    else {\n                        delete this.$syncKeys[key];\n                    }\n                },\n                save(key, value) {\n                    try {\n                        const oldValue = storage.getItem(key);\n                        const data = isString(value) ? value : serializer.stringify(value);\n                        storage.setItem(key, data);\n                        if (oldValue !== data && isClient && store.$syncKeys[key]) {\n                            window.dispatchEvent(new StorageEvent(key, {\n                                newValue: data,\n                                oldValue,\n                                storageArea: storage,\n                            }));\n                        }\n                    }\n                    catch (e) {\n                        quotaError.value = isQuotaExceededError(e, storage);\n                    }\n                },\n                clear() {\n                    this.$refMap.forEach((_, k) => this.removeItem(k));\n                },\n                removeItem(k) {\n                    const item = this.$refMap.get(k);\n                    // remove the object value if item deleted\n                    if (item) {\n                        item.value = undefined;\n                    }\n                    // clear the watch\n                    const stop = this.$watchHandlers.get(k);\n                    if (stop) {\n                        stop();\n                    }\n                    delete this.$syncKeys[k];\n                    this.$refMap.delete(k);\n                    storage.removeItem(k);\n                },\n                getItem(k) {\n                    /**\n                     * NOTE seems if the element who created the `ref` gets destroyed all the watchers assigned will be also disposed\n                     * making returning of the cached `ref` invalid\n                     */\n                    const data = storage.getItem(k);\n                    if (!data) {\n                        return null;\n                    }\n                    return this.setItem(k, safeParse(serializer, data));\n                },\n                getRef(k) {\n                    const item = ref();\n                    let keyWatch = watch(wrap(k), (k) => {\n                        const data = storage.getItem(k);\n                        if (!data) {\n                            return (item.value = null);\n                        }\n                        item.value = safeParse(serializer, data);\n                    }, {\n                        immediate: true,\n                        flush: \"sync\",\n                    });\n                    let valueWatch = watch(item, debounce((i) => {\n                        this.save(unwrap(k), i);\n                    }, ms), { deep: true, flush: \"sync\" });\n                    // used to reference to this ref, since `k` change change we need to generate one\n                    const fakeKey = Math.random().toString();\n                    this.$watchHandlers.set(fakeKey, () => {\n                        keyWatch();\n                        valueWatch();\n                    });\n                    this.$refMap.set(fakeKey, item);\n                    return item;\n                },\n                setItem(k, v) {\n                    const reference = wrap(v);\n                    this.$refMap.set(k, reference);\n                    this.save(k, v);\n                    // @ts-ignore\n                    const stop = watch(reference, debounce((r) => {\n                        this.save(k, r);\n                    }, ms), {\n                        immediate: false,\n                        deep: true,\n                    });\n                    this.$watchHandlers.set(k, stop);\n                    return reference;\n                },\n                updateItem(k, data) {\n                    let r = this.$refMap.get(k);\n                    if (r) {\n                        r.value = safeParse(serializer, data);\n                    }\n                },\n            };\n            storageMap.set(type, store);\n        }\n        else {\n            quotaError = store.$quotaError;\n        }\n    }\n    else {\n        quotaError = ref(false);\n        store = {};\n    }\n    return {\n        supported,\n        quotaError,\n        store,\n        remove,\n    };\n}\n\nfunction useLocalStorage(key, defaultValue, sync) {\n    const { supported, store } = useWebStorage(\"localStorage\");\n    let remove = NO_OP;\n    let clear = NO_OP;\n    let setSync = NO_OP;\n    let storage = undefined;\n    if (supported && store) {\n        setSync = (s) => store.setSync(unwrap(key), s);\n        remove = () => store.removeItem(unwrap(key));\n        clear = () => store.clear();\n        storage = store.getRef(key);\n        if (storage.value == null) {\n            store.save(unwrap(key), defaultValue);\n            storage.value = defaultValue;\n        }\n        watchEffect(() => {\n            if (sync !== false) {\n                setSync(true);\n            }\n        });\n    }\n    else {\n        /* istanbul ignore else */\n        if ((process.env.NODE_ENV !== 'production')) {\n            console.warn(\"[localStorage] is not available\");\n        }\n        storage = ref(defaultValue);\n    }\n    return {\n        supported,\n        storage,\n        clear,\n        remove,\n        setSync,\n    };\n}\n\nfunction useSessionStorage(key, defaultValue, sync) {\n    const { supported, store } = useWebStorage(\"sessionStorage\");\n    let remove = NO_OP;\n    let clear = NO_OP;\n    let setSync = FALSE_OP;\n    let storage = undefined;\n    if (supported && store) {\n        /* istanbul ignore else */\n        if ((process.env.NODE_ENV !== 'production')) {\n            setSync = () => console.warn(\"sync is not supported, please `useLocalStorage` instead\");\n            if (sync) {\n                setSync(sync);\n            }\n        }\n        remove = () => store.removeItem(unwrap(key));\n        clear = () => store.clear();\n        storage = store.getRef(key);\n        if (storage.value == null) {\n            store.save(unwrap(key), defaultValue);\n            storage.value = defaultValue;\n        }\n    }\n    else {\n        /* istanbul ignore else */\n        if ((process.env.NODE_ENV !== 'production')) {\n            console.warn(\"[sessionStorage] is not available\");\n        }\n        storage = ref(defaultValue);\n    }\n    return {\n        supported,\n        storage,\n        clear,\n        remove,\n        setSync,\n    };\n}\n\nlet canUseLocalStorage = undefined;\nfunction useStorage(key, defaultValue, sync) {\n    if (canUseLocalStorage === undefined) {\n        canUseLocalStorage = useWebStorage(\"localStorage\").supported;\n    }\n    return canUseLocalStorage\n        ? useLocalStorage(key, defaultValue, sync)\n        : useSessionStorage(key, defaultValue, sync);\n}\n\n/**\n * Create a pagination controller based on the arguments\n * @param options -\n */\nfunction usePagination(options) {\n    const _currentPage = wrap(options.currentPage);\n    const _pageSize = wrap(options.pageSize);\n    const _offset = ref(0);\n    const total = wrap(options.total);\n    const offset = computed({\n        get() {\n            return _offset.value;\n        },\n        set(v) {\n            if (!isNumber(v)) {\n                /* istanbul ignore else */\n                if ((process.env.NODE_ENV !== 'production')) {\n                    console.warn(`[offset] expected number but got: '${typeof v}' value: '${v}'`);\n                }\n                return;\n            }\n            _offset.value = Math.min(v, total.value);\n        }\n    });\n    const currentPage = computed({\n        get() {\n            return _currentPage.value;\n        },\n        set(v) {\n            if (!isNumber(v)) {\n                /* istanbul ignore else  */\n                if ((process.env.NODE_ENV !== 'production')) {\n                    console.warn(`[currentPage] expected number but got: '${typeof v}' value: '${v}'`);\n                }\n                return;\n            }\n            _currentPage.value = minMax(v, 1, lastPage.value);\n            // set the offset\n            offset.value = (_currentPage.value - 1) * pageSize.value;\n        }\n    });\n    const pageSize = computed({\n        get() {\n            return _pageSize.value;\n        },\n        set(v) {\n            if (!isNumber(v)) {\n                /* istanbul ignore else */\n                if ((process.env.NODE_ENV !== 'production')) {\n                    console.warn(`[pageSize] expected number but got: '${typeof v}' value: '${v}'`);\n                }\n                return;\n            }\n            _pageSize.value = v;\n        }\n    });\n    const lastPage = computed(() => Math.ceil(total.value / pageSize.value));\n    // make sure the current page is the correct value\n    currentPage.value = _currentPage.value;\n    const prev = () => --currentPage.value;\n    const next = () => ++currentPage.value;\n    const first = () => (currentPage.value = 1);\n    const last = () => (currentPage.value = lastPage.value);\n    watch([total, pageSize], _ => {\n        if (currentPage.value > lastPage.value) {\n            currentPage.value = lastPage.value;\n        }\n    }, { immediate: false } // no need to run on first render\n    );\n    return {\n        // Mutable state\n        pageSize,\n        total,\n        currentPage,\n        offset,\n        // Computed\n        lastPage,\n        // Functions\n        next,\n        prev,\n        first,\n        last\n    };\n}\n\nfunction useArrayPagination(array, options) {\n    const arrayRef = wrap(array);\n    const pagination = usePagination({\n        ...{\n            currentPage: 1,\n            pageSize: 10\n        },\n        ...options,\n        total: computed(() => arrayRef.value.length)\n    });\n    const result = computed(() => {\n        const array = arrayRef.value;\n        if (!Array.isArray(array))\n            return [];\n        return array.slice(pagination.offset.value, pagination.offset.value + pagination.pageSize.value);\n    });\n    return {\n        ...pagination,\n        result\n    };\n}\n\n/**\n * Reactive custom timer with specified refresh rate\n * @param options - Configuration\n */\nfunction useNow(options) {\n    const SYNC_MS = 1000;\n    const ms = (options && options.refreshMs) || SYNC_MS;\n    const sync = options && isBoolean(options.sync) ? options.sync : true;\n    const fn = (options && isFunction(options.timeFn) && options.timeFn) || Date.now;\n    /* istanbul ignore else */\n    if ((process.env.NODE_ENV !== 'production')) {\n        if (options && options.timeFn && isFunction(options.timeFn) === false) {\n            console.warn(\"[useNow] timeFn param must be Function\");\n        }\n    }\n    let handler = undefined;\n    let timeoutHandler = undefined;\n    const now = ref(fn());\n    const remove = () => {\n        clearInterval(handler);\n        clearTimeout(timeoutHandler);\n    };\n    /* istanbul ignore next */\n    const start = isClient\n        ? () => (handler = setInterval(() => (now.value = fn()), ms))\n        : NO_OP;\n    if (sync) {\n        const offset = SYNC_MS - (now.value - Math.floor(now.value / SYNC_MS) * SYNC_MS);\n        timeoutHandler = setTimeout(start, offset);\n    }\n    else {\n        start();\n    }\n    onUnmounted(remove);\n    return {\n        now,\n        remove\n    };\n}\n\n/**\n * Reactive `Date.now()` with specified refresh rate\n * @param options - Configuration\n */\nfunction useDateNow(options) {\n    const refreshMs = (options && options.refreshMs) || 1000;\n    const sync = options && isBoolean(options.sync) ? options.sync : true;\n    return useNow({\n        refreshMs,\n        sync,\n        timeFn: Date.now\n    });\n}\n\n/**\n * Reactive `performance.now()` with specified refresh rate\n * @param options - Configuration\n */\nfunction usePerformanceNow(options) {\n    const refreshMs = (options && options.refreshMs) || 1000;\n    const sync = options && isBoolean(options.sync) ? options.sync : true;\n    return useNow({\n        refreshMs,\n        sync,\n        timeFn: () => performance.now()\n    });\n}\n\nfunction useFormat(format, args) {\n    return computed(() => {\n        const f = unwrap(format);\n        if (!args) {\n            return f;\n        }\n        const r = isRef(args) ? reactive(args.value) : reactive(args);\n        const regEx = /({?{[\\w\\s]*}?})/g;\n        return f.replace(regEx, s => {\n            const k = s\n                .replace(\"{\", \"\")\n                .replace(\"}\", \"\")\n                .trim();\n            // ignore if {{ }}\n            if (s[0] === s[1] && s[0] === \"{\") {\n                return `${k}`;\n            }\n            const v = isArray(r) ? r[+k] : r[k];\n            return v === undefined ? s : `${unwrap(v)}`;\n        });\n    });\n}\n\n/**\n * Retrieve object value based on string path\n * @param source - Source object to retrieve path\n * @param path - string path to value\n * @param separator - path separator, default '.'\n * @param notFoundReturn - not found handler\n */\nfunction usePath(source, path, separator = \".\", notFoundReturn = NO_OP) {\n    return computed(() => {\n        const s = unwrap(source);\n        const p = unwrap(path);\n        if (s === undefined)\n            return notFoundReturn(p, s, p, s);\n        if (!p) {\n            return s;\n        }\n        const fragments = p.split(separator);\n        let c = s;\n        for (let i = 0; i < fragments.length; i++) {\n            let fragmentPath = fragments[i];\n            if (fragmentPath[fragmentPath.length - 1] === \"]\") {\n                const r = /\\[[`'\"]?([^`'\"\\]]*)[`'\"]?\\]/g;\n                let path = fragmentPath;\n                let m = r.exec(path);\n                if (m) {\n                    let lastLen = m[0].length;\n                    let lastIndex = m.index - lastLen;\n                    let mi = 1;\n                    do {\n                        if (lastIndex + lastLen !== m.index) {\n                            // istanbul ignore else\n                            if ((process.env.NODE_ENV !== 'production')) {\n                                console.warn(`[usePath] invalid path \"${fragments[i]}\"`);\n                            }\n                        }\n                        lastIndex = m.index;\n                        lastLen = m[0].length;\n                        fragmentPath = fragmentPath.slice(0, -m[0].length);\n                        fragments.splice(i + mi, 0, m[1]);\n                        ++mi;\n                    } while ((m = r.exec(path)));\n                    // if the fragmentPath is empty, eg: [1][1]\n                    // we should continue until the next path\n                    if (!fragmentPath && path[0] === \"[\" && path.length > 2) {\n                        continue;\n                    }\n                }\n                else {\n                    fragmentPath = \"\";\n                    console.warn(`[usePath] invalid path provided \"${path}\"`);\n                }\n            }\n            if (isObject(c)) {\n                if (!fragmentPath) {\n                    // istanbul ignore else\n                    if ((process.env.NODE_ENV !== 'production')) {\n                        console.warn(`Path \"${fragments\n                            .slice(0, i + 1)\n                            .join(separator)}\" doesn't exist on:`, source);\n                    }\n                    return notFoundReturn(fragments.slice(0, i + 1).join(separator), c, p, s);\n                }\n                c = c[fragmentPath];\n            }\n            else {\n                // istanbul ignore else\n                if ((process.env.NODE_ENV !== 'production')) {\n                    console.warn(`Path \"${fragments\n                        .slice(0, i + 1)\n                        .join(separator)}\" doesn't exist on:`, source);\n                }\n                return notFoundReturn(fragments.slice(0, i + 1).join(separator), c, p, s);\n            }\n            if (!c) {\n                // istanbul ignore else\n                if ((process.env.NODE_ENV !== 'production')) {\n                    console.warn(`Path \"${fragments\n                        .slice(0, i + 1)\n                        .join(separator)}\" doesn't exist on:`, source);\n                }\n                return notFoundReturn(fragments.slice(0, i + 1).join(separator), c, p, s);\n            }\n        }\n        return c;\n    });\n}\n\n/* /Output */\nfunction isValidation(v) {\n    return typeof v.$value !== \"undefined\";\n}\nfunction isValidatorObject(v) {\n    return isObject(v);\n}\nconst buildValidationFunction = (r, f, m, handlers) => {\n    const $promise = ref(null);\n    const $pending = ref(false);\n    const $error = ref();\n    const $invalid = ref(false);\n    let context = undefined;\n    const onChange = (r) => {\n        const p = async () => {\n            try {\n                $pending.value = true;\n                const result = f(r, context);\n                if (isPromise(result)) {\n                    $invalid.value = !(await result);\n                }\n                else {\n                    $invalid.value = !result;\n                }\n                // @ts-ignore\n                $error.value = $invalid.value ? m.value || true : undefined;\n            }\n            catch (e) {\n                $invalid.value = true;\n                throw e;\n            }\n            finally {\n                $pending.value = false;\n            }\n        };\n        $promise.value = p().catch((x) => {\n            $error.value = unwrap(x);\n            $invalid.value = true;\n            return x;\n        });\n    };\n    handlers.push((ctx) => {\n        context = ctx;\n        watch(() => {\n            try {\n                // keep track on the external dependencies\n                f(r.value, context);\n            }\n            catch (e) {\n                // ignore error\n            }\n            return r.value;\n        }, onChange, { deep: true, immediate: true });\n    });\n    function $touch() {\n        onChange(r.value);\n    }\n    return {\n        $promise,\n        $pending,\n        $invalid,\n        $error,\n        $touch,\n    };\n};\nconst buildValidationValue = (r, v, handlers) => {\n    const { $message, $validator, ...$rest } = isValidatorObject(v)\n        ? v\n        : { $validator: v, $message: undefined };\n    const { $pending, $promise, $invalid, $error, $touch, } = buildValidationFunction(r, $validator, ref($message), handlers);\n    return {\n        $pending,\n        $error,\n        $promise,\n        $invalid,\n        $message,\n        $touch,\n        ...$rest,\n    };\n};\nconst buildValidation = (o, handlers) => {\n    const r = {};\n    const $value = isValidation(o) ? wrap(o.$value) : undefined;\n    for (const k of Object.keys(o)) {\n        if (k[0] === \"$\") {\n            if (k === \"$value\") {\n                r[k] = $value;\n                const $dirty = ref(false);\n                let dirtyWatch = NO_OP;\n                const createDirtyWatcher = () => {\n                    dirtyWatch();\n                    dirtyWatch = watch($value, () => {\n                        $dirty.value = true;\n                        dirtyWatch();\n                    }, { immediate: false, deep: true });\n                };\n                createDirtyWatcher();\n                r[\"$dirty\"] = $dirty;\n                r[\"$reset\"] = () => {\n                    $dirty.value = false;\n                    createDirtyWatcher();\n                };\n                r[\"$touch\"] = () => ($dirty.value = true);\n                // @ts-ignore\n                r.toObject = () => unwrap($value);\n                continue;\n            }\n            else {\n                r[k] = o[k];\n                continue;\n            }\n        }\n        if ($value) {\n            const validation = buildValidationValue($value, o[k], handlers);\n            // @ts-expect-error no valid type\n            r[k] = validation;\n        }\n        else {\n            const validation = buildValidation(o[k], handlers);\n            let $anyDirty = undefined;\n            let $errors;\n            let $anyInvalid;\n            let toObject = NO_OP;\n            if (isValidation(validation)) {\n                const validations = Object.keys(validation)\n                    .filter((x) => x[0] !== \"$\")\n                    .map((x) => validation[x]);\n                $errors = computed(() => validations\n                    .map((x) => x.$error)\n                    .map((x) => unwrap(x))\n                    .filter((x) => x !== undefined));\n                // $anyDirty = computed(() => validations.some(x => !!x));\n                $anyInvalid = computed(() => validations.some((x) => {\n                    return !!unwrap(x.$invalid);\n                }));\n                toObject = () => {\n                    return Object.keys(validation)\n                        .filter((x) => x[0] !== \"$\")\n                        .reduce((p, c) => {\n                        //@ts-ignore\n                        p[c] = validation[c].toObject();\n                        return p;\n                    }, {});\n                };\n            }\n            else {\n                const validations = Object.keys(validation).map((x) => validation[x]);\n                $errors = computed(() => {\n                    return validations\n                        .map((x) => unwrap(x.$errors))\n                        .filter((x) => x !== undefined)\n                        .filter((x) => {\n                        return x.some(Boolean);\n                    });\n                });\n                $anyDirty = computed(() => {\n                    return validations.some((x) => {\n                        return (unwrap(x.$anyDirty) ||\n                            (isBoolean(unwrap(x.$dirty)) &&\n                                unwrap(x.$dirty)));\n                    });\n                });\n                $anyInvalid = computed(() => validations.some((x) => {\n                    return !!unwrap(x.$anyInvalid);\n                }));\n                toObject = () => {\n                    return Object.keys(validation)\n                        .filter((x) => x[0] !== \"$\")\n                        .reduce((p, c) => {\n                        //@ts-ignore\n                        p[c] = validation[c].toObject();\n                        return p;\n                    }, {});\n                };\n            }\n            r[k] = {\n                toObject,\n                ...validation,\n                $errors,\n                $anyInvalid,\n            };\n            if ($anyDirty) {\n                r[k].$anyDirty = $anyDirty;\n                const keys = Object.keys(r[k]).filter((x) => x[0] !== \"$\" && isObject(r[k][x]));\n                r[k].$touch = () => {\n                    // r[k].\n                    keys.forEach((m) => {\n                        const touch = r[k][m].$touch;\n                        if (touch) {\n                            touch();\n                        }\n                    });\n                };\n                r[k].$reset = () => {\n                    keys.forEach((m) => {\n                        const reset = r[k][m].$reset;\n                        if (reset) {\n                            reset();\n                        }\n                    });\n                };\n            }\n        }\n    }\n    return r;\n};\nfunction useValidation(input) {\n    const handlers = [];\n    const validation = buildValidation({ input }, handlers);\n    // convert to reactive, this will make it annoying to deconstruct, but\n    // allows to use it directly on the render template without `.value`\n    // https://github.com/vuejs/vue-next/pull/738\n    // @ts-expect-error TODO check this error\n    const validationInput = reactive(validation.input);\n    // set the context, this will allow to use this object as the second\n    // argument when calling validators\n    handlers.forEach((x) => x(validationInput));\n    return validationInput;\n}\n\n// istanbul ignore next\n// Symbol used to inject/provide the i18n values\nconst I18n_ACCESS_SYMBOL = Symbol(((process.env.NODE_ENV !== 'production') && \"I18n\") || ``);\nfunction useI18n(definition) {\n    if (definition) {\n        return setI18n(definition);\n    }\n    else\n        return inject(I18n_ACCESS_SYMBOL);\n}\n/**\n * Builds i18n object based on the definition\n * @param definition - i18n definition\n */\nfunction buildI18n(definition) {\n    const locales = ref(Object.keys(definition.messages));\n    const localeMessages = ref(definition.messages);\n    const locale = ref(definition.locale);\n    const i18n = ref({});\n    let fallback = ref();\n    const cache = {};\n    const retrieveLocaleValue = (x) => {\n        return (\"__esModule\" in x || x[Symbol.toStringTag] === \"Module\") &&\n            \"default\" in x\n            ? x.default\n            : x;\n    };\n    const loadLocale = (locale, messages) => {\n        if (cache[locale]) {\n            return cache[locale];\n        }\n        const l = messages.value[locale];\n        if (!l) {\n            return ref({});\n        }\n        let m = isFunction(l) ? l() : l;\n        if (isPromise(m)) {\n            return m.then((x) => {\n                return (cache[locale] = wrap(retrieveLocaleValue(x)));\n            });\n        }\n        // if it was function we don't keep track on that\n        if (isFunction(l)) {\n            // return wrap(m)\n            return wrap(retrieveLocaleValue(m));\n        }\n        return (cache[locale] = computed(() => retrieveLocaleValue(messages.value[locale])));\n    };\n    const shouldFallback = definition.fallback\n        ? isBoolean(definition.notFoundFallback)\n            ? definition.notFoundFallback\n            : true\n        : false;\n    let fallbackIsPromise = false;\n    if (shouldFallback) {\n        const fallbackI18n = loadLocale(definition.fallback, localeMessages);\n        if (isPromise(fallbackI18n)) {\n            fallbackI18n.then((x) => {\n                fallback.value = x.value;\n            });\n            fallbackIsPromise = true;\n        }\n        else {\n            fallback.value = fallbackI18n.value;\n        }\n    }\n    else {\n        fallback.value = {};\n    }\n    const localeChangesCount = ref(0);\n    watch(localeMessages, () => localeChangesCount.value++, {\n        deep: true,\n        immediate: false,\n    });\n    watch([locale, fallback, localeChangesCount], ([l, fb, _]) => {\n        if (l === definition.fallback && shouldFallback) {\n            i18n.value = fb;\n        }\n        else {\n            const setI18n = (v) => (i18n.value = deepClone({}, fb, unwrap(v)));\n            // const localeMessage = await loadLocale(l as string, localeMessages);\n            // i18n.value = deepClone<any>({}, fb, localeMessage.value);\n            const r = loadLocale(l, localeMessages);\n            if (isPromise(r)) {\n                r.then(setI18n);\n            }\n            else {\n                setI18n(r);\n            }\n        }\n    }, {\n        immediate: !fallbackIsPromise,\n    });\n    const $t = (path, args) => {\n        if (definition.resolve) {\n            return wrap(definition.resolve(i18n.value, path, args));\n        }\n        return useFormat(usePath(i18n, path, \".\", (_, _1, p, _2) => p), args);\n    };\n    const $ts = (path, args) => {\n        return $t(path, args).value;\n    };\n    const addLocale = (l, m) => {\n        if (locales.value.indexOf(l) >= 0) {\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                console.warn(`[useI18n] Locale \"${l}\" already exists, overriding it...`);\n            }\n        }\n        else {\n            locales.value.push(l);\n        }\n        delete cache[l];\n        // istanbul ignore if\n        {\n            localeMessages.value[l] = m;\n        }\n    };\n    const removeLocale = (l) => {\n        const index = locales.value.indexOf(l);\n        if (index >= 0) {\n            const nextLocale = [\n                locale.value,\n                fallback.value && definition.fallback,\n                ...locales.value,\n            ].find((x) => x && x !== l);\n            if (nextLocale) {\n                if (l === definition.fallback) {\n                    /* istanbul ignore else */\n                    if ((process.env.NODE_ENV !== 'production')) {\n                        console.warn(`[useI18n] removing default fallback locale \"${l}\"`);\n                    }\n                    fallback.value = undefined;\n                }\n                if (l === locale.value) {\n                    /* istanbul ignore else */\n                    if ((process.env.NODE_ENV !== 'production')) {\n                        console.warn(`[useI18n] removing current locale \"${l}\", setting current locale to \"${nextLocale}\"`);\n                    }\n                    locale.value = nextLocale;\n                }\n            }\n            else {\n                /* istanbul ignore else */\n                if ((process.env.NODE_ENV !== 'production')) {\n                    console.error(\"[useI18n] No locales available to use\");\n                }\n            }\n            locales.value.splice(index, 1);\n        }\n        else {\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                console.warn(`[useI18n] Locale \"${l}\" doesn't exist`);\n            }\n        }\n        // istanbul ignore else\n        {\n            delete localeMessages.value[l];\n        }\n        delete cache[l];\n    };\n    return {\n        locale,\n        locales,\n        i18n,\n        $t,\n        $ts,\n        addLocale,\n        removeLocale,\n    };\n}\n/**\n * Build and provide i18n definition\n * @param definition - I18N definition\n */\nfunction setI18n(definition) {\n    const r = buildI18n(definition);\n    provide(I18n_ACCESS_SYMBOL, r);\n    return r;\n}\n\n// istanbul ignore next\nconst SSR_TITLE_KEY = Symbol(((process.env.NODE_ENV !== 'production') && \"SSR_TITLE_KEY\") || ``);\nfunction provideSSRTitle(app, title) {\n    const r = wrap(title === undefined ? \"\" : title);\n    app.provide(SSR_TITLE_KEY, r);\n    return r;\n}\nfunction useSSRTitle(defaultTitle) {\n    const s = Symbol();\n    const title = inject(SSR_TITLE_KEY, s);\n    // @ts-ignore check if it exists\n    if (title === s) {\n        /* istanbul ignore else */\n        if ((process.env.NODE_ENV !== 'production')) {\n            console.warn(\"[useSSRTitle] can't find SSRTitle have you forgotten calling `provideSSRTitle`?\");\n        }\n        // istanbul ignore next\n        return ref(isString(defaultTitle) ? defaultTitle : \"\");\n    }\n    if (title === undefined) {\n        // probably not in `setup()`\n        // istanbul ignore next\n        return ref(isString(defaultTitle) ? defaultTitle : \"\");\n    }\n    if (isString(defaultTitle)) {\n        title.value = defaultTitle;\n    }\n    return title;\n}\nfunction useTitle(overrideTitle = null) {\n    if (((globalThis.import ? globalThis.import.meta.env.SSR : process.env.SSR )) && !isClient) {\n        return useSSRTitle(overrideTitle);\n    }\n    const title = ref(isString(overrideTitle) ? overrideTitle : document.title);\n    const observer = new MutationObserver(m => {\n        title.value = m[0].target.textContent;\n    });\n    watch(title, (t, o) => {\n        if (isString(t) && t !== o) {\n            document.title = t;\n        }\n    }, {\n        immediate: true,\n        flush: \"sync\"\n    });\n    const titleElement = document.querySelector(\"title\");\n    observer.observe(titleElement, { childList: true });\n    onUnmounted(() => observer.disconnect());\n    return title;\n}\n\n// istanbul ignore next\nconst HYDRATION_KEY = Symbol(((process.env.NODE_ENV !== 'production') && \"VUE_COMPOSABLE_HYDRATION_KEY\") || ``);\nconst hydrationPlugin = {\n    // @ts-ignore\n    install(app) {\n        const hydrating = ref(true);\n        const h = readonly(hydrating);\n        {\n            // @ts-ignore\n            app._context.provides[HYDRATION_KEY] = h;\n            const appMount = app.mount;\n            app.mount = (...args) => {\n                const component = appMount(...args);\n                hydrating.value = false;\n                return component;\n            };\n        }\n    }\n};\nfunction useHydration() {\n    if ((process.env.NODE_ENV !== 'production')) {\n        const s = Symbol();\n        const r = inject(HYDRATION_KEY, s);\n        if (r === s) {\n            console.warn(\"[useHydration] no hydration found, did you forget to `app.use(HydrationPlugin)`?\");\n        }\n    }\n    return inject(HYDRATION_KEY, computed(() => false));\n}\n\nfunction useValueSync(main, args) {\n    const master = wrap(main);\n    const list = arguments.length === 2\n        ? isRef(arguments[1]) && isArray(arguments[1].value)\n            ? arguments[1]\n            : ref([wrap(arguments[1])])\n        : ref(Array.from(arguments)\n            .slice(1)\n            .map(x => wrap(x)));\n    list.value.forEach(x => {\n        x.value = master.value;\n    });\n    let lastLen = list.value.length;\n    watch([master, list], ([m, list]) => {\n        // value added set master\n        if (lastLen < list.length) {\n            list.forEach(x => {\n                if (x.value !== m) {\n                    x.value = m;\n                }\n            });\n            return;\n        }\n        lastLen = list.length;\n        for (const v of list) {\n            if (v.value !== m) {\n                master.value = v.value;\n                return;\n            }\n        }\n    }, {\n        deep: true\n    });\n    watch(master, m => {\n        list.value.forEach(x => (x.value = m));\n    }, {\n        deep: true,\n        flush: \"sync\"\n    });\n    return list;\n}\n\nfunction useTimeline(value, options) {\n    const timeline = ref([]);\n    const clone = options && options.clone ? options.clone : (x) => x;\n    const maxLength = (options && options.maxLength) || MAX_ARRAY_SIZE;\n    watch(value, (_, o) => {\n        timeline.value.unshift({\n            item: clone(o),\n            date: new Date()\n        });\n        if (timeline.value.length > maxLength) {\n            timeline.value.pop();\n        }\n    }, {\n        immediate: false,\n        flush: \"sync\",\n        // allow options to override defaults\n        ...options\n    });\n    return readonly(timeline);\n}\n\nfunction useUndo(defaultValue, options) {\n    const current = wrap(defaultValue);\n    const timeline = ref([]);\n    const position = ref(0);\n    const maxLen = (options && options.maxLength) || MAX_ARRAY_SIZE;\n    const clone = (options && options.clone) || ((t) => t);\n    const prev = computed(() => {\n        // hide current\n        const p = position.value === 0 ? 1 : position.value;\n        return timeline.value.slice(p);\n    });\n    const next = computed(() => {\n        // hide current\n        const p = position.value === 0 ? 1 : 0;\n        return timeline.value.slice(p, position.value);\n    });\n    let addTimelineEvent = undefined;\n    if ((process.env.NODE_ENV !== 'production') && options && options.devtoolId) {\n        const layer = useDevtoolsTimelineLayer(`useUndo:${options.devtoolId}`, options.devtoolId, 0x32a2bf // TODO devtools fix color\n        );\n        addTimelineEvent = (time, data) => layer.addEvent({\n            time,\n            data: {\n                value: data,\n                prev: [...prev.value],\n                next: [...next.value],\n            },\n            meta: {\n                prev: [...prev.value],\n                next: [...next.value],\n            },\n        });\n    }\n    watch(current, (c) => {\n        if (timeline.value[position.value] === c) {\n            //ignore because is the same value\n            return;\n        }\n        // new value added\n        if (position.value > 0) {\n            const pos = position.value;\n            timeline.value.splice(0, pos);\n            // reset position\n            position.value = 0;\n        }\n        if (timeline.value.length > maxLen) {\n            timeline.value.pop();\n        }\n        const v = clone(c);\n        timeline.value.unshift(v);\n        if (addTimelineEvent) {\n            addTimelineEvent(Date.now(), c);\n        }\n    }, {\n        ...options,\n        immediate: true,\n        flush: \"sync\",\n    });\n    const undo = (step = 1) => jump(step);\n    const redo = (step = 1) => jump(-step);\n    const jump = (delta) => {\n        const s = Math.sign(delta) <= 0\n            ? Math.max(delta, -next.value.length)\n            : Math.min(delta, prev.value.length);\n        position.value += s;\n        current.value = timeline.value[position.value];\n        if (addTimelineEvent) {\n            addTimelineEvent(Date.now(), clone(current.value));\n        }\n    };\n    return {\n        value: current,\n        undo,\n        redo,\n        jump,\n        prev,\n        next,\n    };\n}\n\nfunction useMouseDistanceFromElement(el, options, wait) {\n    let distance = undefined;\n    let remove = NO_OP;\n    if (isClient) {\n        // @ts-ignore\n        const { pageX, pageY, remove: removeMouseEvent } = useOnMouseMove(window, options, wait);\n        distance = computed(() => {\n            const elem = unwrap(el);\n            if (!elem)\n                return 0;\n            return Math.floor(Math.sqrt(Math.pow(pageX.value - (elem.offsetLeft + elem.clientWidth / 2), 2) +\n                Math.pow(pageY.value - (elem.offsetTop + elem.clientHeight / 2), 2)));\n        });\n        remove = removeMouseEvent;\n    }\n    else {\n        distance = computed(() => -1);\n    }\n    return {\n        distance,\n        remove,\n    };\n}\n\nconst VERSION = \"1.0.0-beta.24\";\n// istanbul ignore next\nconst VUE_VERSION = \"3\";\nconst COMMIT = \"cca1e18\";\n\nexport { COMMIT, FALSE_OP, MAX_ARRAY_SIZE, NO_OP, PASSIVE_EV, SCROLL_LOCK_CLASS, UseDevtoolsApp, VERSION, VUE_VERSION, VueComposableDevtools, buildI18n, debounce, deepClone, exponentialDelay, exposeWorker, getCssVariableFor, getDevtools, hydrationPlugin, injectFactory, isArray, isBoolean, isClient, isDate, isElement, isFunction, isNull, isNumber, isObject, isPromise, isString, isSymbol, isUndefined, minMax, noDelay, promisedTimeout, provideSSRTitle, refDebounced, refShared, setBreakpointTailwindCSS, setCssVariableFor, setDevtools, setI18n, storageAvailable, unwrap, useArrayPagination, useBreakpoint, useBreakpointChrome, useBreakpointTailwindCSS, useBroadcastChannel, useCancellablePromise, useClipboard, useCssVariables, useCurrencyFormat, useDateNow, useDebounce, useDevtoolsComponentState, useDevtoolsInspector, useDevtoolsTimelineLayer, useEvent, useFetch, useFormat, useGeolocation, useHydration, useI18n, useIntersectionObserver, useInterval, useIntlDateTimeFormat, useIntlNumberFormat, useLanguage, useLocalStorage, useLockScroll, useMatchMedia, useMouseDistanceFromElement, useNetworkInformation, useNow, useOnMouseMove, useOnOutsidePress, useOnResize, useOnScroll, useOnline, usePageVisibility, usePagination, usePath, usePerformanceNow, usePromise, usePromiseLazy, useRetry, useSSRTitle, useSessionStorage, useShare, useSharedRef, useStorage, useTimeline, useTimeout, useTitle, useUndo, useVModel, useValidation, useValueSync, useWebSocket, useWebStorage, useWorker, useWorkerFunction, wrap };\n", "import { ref, watch } from 'vue';\nimport Cookies from 'js-cookie';\nimport { isUndefined, isNull } from 'vue-composable';\n\nfunction useCookie(key, defaultValue, defaultOptions) {\n    let cookie = ref(null);\n    let _options;\n    let value = Cookies.get(key);\n    if (isUndefined(value)) {\n        cookie.value = defaultValue;\n        if (!isUndefined(defaultValue) && !isNull(defaultValue)) {\n            Cookies.set(key, defaultValue, defaultOptions);\n            _options = defaultOptions;\n        }\n    }\n    else {\n        cookie.value = value;\n    }\n    const setCookie = (newValue, options) => {\n        cookie.value = newValue;\n        _options = options;\n        Cookies.set(key, cookie.value, _options);\n    };\n    const removeCookie = () => {\n        cookie.value = undefined;\n        Cookies.remove(key, _options);\n    };\n    watch(cookie, (cookie, prevCookie) => {\n        if (isUndefined(cookie) || isNull(cookie)) {\n            Cookies.remove(key, _options);\n        }\n        else if (cookie !== prevCookie) {\n            Cookies.set(key, cookie, _options);\n        }\n    }, {\n        deep: true,\n    });\n    return {\n        cookie,\n        setCookie,\n        removeCookie,\n    };\n}\n\nexport { useCookie };\n"],
  "mappings": "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",
  "names": ["init_api", "init_api", "converter", "api", "setupDevtoolsPlugin", "cookie"]
}
