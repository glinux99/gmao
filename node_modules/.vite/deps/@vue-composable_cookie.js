import {
  ref,
  watch
} from "./chunk-HB5I462T.js";
import {
  __esm,
  __export,
  __toCommonJS
} from "./chunk-JJ3PYKI2.js";

// node_modules/@vue/devtools-api/lib/esm/env.js
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
}
var isProxyAvailable;
var init_env = __esm({
  "node_modules/@vue/devtools-api/lib/esm/env.js"() {
    isProxyAvailable = typeof Proxy === "function";
  }
});

// node_modules/@vue/devtools-api/lib/esm/const.js
var HOOK_SETUP, HOOK_PLUGIN_SETTINGS_SET;
var init_const = __esm({
  "node_modules/@vue/devtools-api/lib/esm/const.js"() {
    HOOK_SETUP = "devtools-plugin:setup";
    HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
  }
});

// node_modules/@vue/devtools-api/lib/esm/time.js
function isPerformanceSupported() {
  var _a;
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof globalThis !== "undefined" && ((_a = globalThis.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
    supported = true;
    perf = globalThis.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
function now() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}
var supported, perf;
var init_time = __esm({
  "node_modules/@vue/devtools-api/lib/esm/time.js"() {
  }
});

// node_modules/@vue/devtools-api/lib/esm/proxy.js
var ApiProxy;
var init_proxy = __esm({
  "node_modules/@vue/devtools-api/lib/esm/proxy.js"() {
    init_const();
    init_time();
    ApiProxy = class {
      constructor(plugin, hook) {
        this.target = null;
        this.targetQueue = [];
        this.onQueue = [];
        this.plugin = plugin;
        this.hook = hook;
        const defaultSettings = {};
        if (plugin.settings) {
          for (const id in plugin.settings) {
            const item = plugin.settings[id];
            defaultSettings[id] = item.defaultValue;
          }
        }
        const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
        let currentSettings = Object.assign({}, defaultSettings);
        try {
          const raw = localStorage.getItem(localSettingsSaveId);
          const data = JSON.parse(raw);
          Object.assign(currentSettings, data);
        } catch (e) {
        }
        this.fallbacks = {
          getSettings() {
            return currentSettings;
          },
          setSettings(value) {
            try {
              localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
            } catch (e) {
            }
            currentSettings = value;
          },
          now() {
            return now();
          }
        };
        if (hook) {
          hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
            if (pluginId === this.plugin.id) {
              this.fallbacks.setSettings(value);
            }
          });
        }
        this.proxiedOn = new Proxy({}, {
          get: (_target, prop) => {
            if (this.target) {
              return this.target.on[prop];
            } else {
              return (...args) => {
                this.onQueue.push({
                  method: prop,
                  args
                });
              };
            }
          }
        });
        this.proxiedTarget = new Proxy({}, {
          get: (_target, prop) => {
            if (this.target) {
              return this.target[prop];
            } else if (prop === "on") {
              return this.proxiedOn;
            } else if (Object.keys(this.fallbacks).includes(prop)) {
              return (...args) => {
                this.targetQueue.push({
                  method: prop,
                  args,
                  resolve: () => {
                  }
                });
                return this.fallbacks[prop](...args);
              };
            } else {
              return (...args) => {
                return new Promise((resolve) => {
                  this.targetQueue.push({
                    method: prop,
                    args,
                    resolve
                  });
                });
              };
            }
          }
        });
      }
      async setRealTarget(target) {
        this.target = target;
        for (const item of this.onQueue) {
          this.target.on[item.method](...item.args);
        }
        for (const item of this.targetQueue) {
          item.resolve(await this.target[item.method](...item.args));
        }
      }
    };
  }
});

// node_modules/@vue/devtools-api/lib/esm/api/api.js
var init_api = __esm({
  "node_modules/@vue/devtools-api/lib/esm/api/api.js"() {
  }
});

// node_modules/@vue/devtools-api/lib/esm/api/app.js
var init_app = __esm({
  "node_modules/@vue/devtools-api/lib/esm/api/app.js"() {
  }
});

// node_modules/@vue/devtools-api/lib/esm/api/component.js
var init_component = __esm({
  "node_modules/@vue/devtools-api/lib/esm/api/component.js"() {
  }
});

// node_modules/@vue/devtools-api/lib/esm/api/context.js
var init_context = __esm({
  "node_modules/@vue/devtools-api/lib/esm/api/context.js"() {
  }
});

// node_modules/@vue/devtools-api/lib/esm/api/hooks.js
var init_hooks = __esm({
  "node_modules/@vue/devtools-api/lib/esm/api/hooks.js"() {
  }
});

// node_modules/@vue/devtools-api/lib/esm/api/util.js
var init_util = __esm({
  "node_modules/@vue/devtools-api/lib/esm/api/util.js"() {
  }
});

// node_modules/@vue/devtools-api/lib/esm/api/index.js
var init_api2 = __esm({
  "node_modules/@vue/devtools-api/lib/esm/api/index.js"() {
    init_api();
    init_app();
    init_component();
    init_context();
    init_hooks();
    init_util();
  }
});

// node_modules/@vue/devtools-api/lib/esm/plugin.js
var init_plugin = __esm({
  "node_modules/@vue/devtools-api/lib/esm/plugin.js"() {
  }
});

// node_modules/@vue/devtools-api/lib/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  isPerformanceSupported: () => isPerformanceSupported,
  now: () => now,
  setupDevtoolsPlugin: () => setupDevtoolsPlugin
});
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy) {
      setupFn(proxy.proxiedTarget);
    }
  }
}
var init_esm = __esm({
  "node_modules/@vue/devtools-api/lib/esm/index.js"() {
    init_env();
    init_const();
    init_proxy();
    init_api2();
    init_plugin();
    init_time();
  }
});

// node_modules/js-cookie/dist/js.cookie.mjs
function assign(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      target[key] = source[key];
    }
  }
  return target;
}
var defaultConverter = {
  read: function(value) {
    if (value[0] === '"') {
      value = value.slice(1, -1);
    }
    return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
  },
  write: function(value) {
    return encodeURIComponent(value).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    );
  }
};
function init(converter, defaultAttributes) {
  function set(name, value, attributes) {
    if (typeof document === "undefined") {
      return;
    }
    attributes = assign({}, defaultAttributes, attributes);
    if (typeof attributes.expires === "number") {
      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
    }
    if (attributes.expires) {
      attributes.expires = attributes.expires.toUTCString();
    }
    name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
    var stringifiedAttributes = "";
    for (var attributeName in attributes) {
      if (!attributes[attributeName]) {
        continue;
      }
      stringifiedAttributes += "; " + attributeName;
      if (attributes[attributeName] === true) {
        continue;
      }
      stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
    }
    return document.cookie = name + "=" + converter.write(value, name) + stringifiedAttributes;
  }
  function get(name) {
    if (typeof document === "undefined" || arguments.length && !name) {
      return;
    }
    var cookies = document.cookie ? document.cookie.split("; ") : [];
    var jar = {};
    for (var i = 0; i < cookies.length; i++) {
      var parts = cookies[i].split("=");
      var value = parts.slice(1).join("=");
      try {
        var found = decodeURIComponent(parts[0]);
        jar[found] = converter.read(value, found);
        if (name === found) {
          break;
        }
      } catch (e) {
      }
    }
    return name ? jar[name] : jar;
  }
  return Object.create(
    {
      set,
      get,
      remove: function(name, attributes) {
        set(
          name,
          "",
          assign({}, attributes, {
            expires: -1
          })
        );
      },
      withAttributes: function(attributes) {
        return init(this.converter, assign({}, this.attributes, attributes));
      },
      withConverter: function(converter2) {
        return init(assign({}, this.converter, converter2), this.attributes);
      }
    },
    {
      attributes: { value: Object.freeze(defaultAttributes) },
      converter: { value: Object.freeze(converter) }
    }
  );
}
var api = init(defaultConverter, { path: "/" });

// node_modules/vue-composable/dist/vue-composable.esm-bundler.js
var isArray = Array.isArray;
var isUndefined = (val) => typeof val === "undefined";
var isNull = (val) => val === null;
var NO_OP = () => {
};
function promisedTimeout(timeout) {
  return new Promise((res) => {
    setTimeout(res, timeout);
  });
}
var MAX_ARRAY_SIZE = 2 ** 32 - 2;
var ExecutionId = Symbol("RetryId");
var CancellationToken = Symbol("CancellationToken");
var DEVTOOLS_KEY = Symbol("DEVTOOLS_KEY");
var apiProxyFactory = void 0;
async function pushEventsToApi(api2, EventQueue, ApiQueue) {
  setTimeout(async () => {
    const priority = [
      "addTimelineLayer",
      "addInspector",
      "sendInspectorTree",
      "sendInspectorState",
      "addTimelineEvent"
    ];
    for (const k of priority) {
      for (const it of ApiQueue.filter((x) => x.type === k)) {
        api2[k](...it.args);
      }
      await promisedTimeout(20);
    }
    new Set(ApiQueue.filter((x) => x.type === "notifyComponentUpdate").map((x) => x.args[0])).forEach((x) => api2.notifyComponentUpdate(x));
    EventQueue.forEach((x) => api2.on[x.type](...x.args));
    EventQueue.length = 0;
    ApiQueue.length = 0;
  }, 100);
}
{
  apiProxyFactory = (promiseApi) => {
    let api2;
    const EventQueue = [];
    const ApiQueue = [];
    const onProxy = new Proxy({}, {
      get: (target, prop) => {
        if (api2) {
          return api2.on[prop];
        } else if (prop in target) {
          return target[prop];
        } else {
          return target[prop] = (...args) => {
            EventQueue.push({
              type: prop,
              args
            });
          };
        }
      }
    });
    const proxy = new Proxy({
      on: onProxy
    }, {
      get: (target, prop) => {
        if (prop === "on") {
          return target.on;
        }
        if (api2) {
          return api2[prop];
        }
        if (prop in target) {
          return target[prop];
        }
        return target[prop] = (...args) => {
          ApiQueue.push({
            type: prop,
            args
          });
        };
      }
    });
    promiseApi.then((x) => {
      api2 = x;
      pushEventsToApi(api2, EventQueue, ApiQueue);
    });
    return proxy;
  };
}
var setupDevtoolsPlugin2 = NO_OP;
if (true) {
  try {
    setupDevtoolsPlugin2 = (init_esm(), __toCommonJS(esm_exports)).setupDevtoolsPlugin;
  } catch {
  }
}
var BREAKPOINT_TAILWIND_KEY = Symbol("TAILWIND_BREAKPOINTS");
var I18n_ACCESS_SYMBOL = Symbol("I18n");
var SSR_TITLE_KEY = Symbol("SSR_TITLE_KEY");
var HYDRATION_KEY = Symbol("VUE_COMPOSABLE_HYDRATION_KEY");

// node_modules/@vue-composable/cookie/dist/cookie.esm-bundler.js
function useCookie(key, defaultValue, defaultOptions) {
  let cookie = ref(null);
  let _options;
  let value = api.get(key);
  if (isUndefined(value)) {
    cookie.value = defaultValue;
    if (!isUndefined(defaultValue) && !isNull(defaultValue)) {
      api.set(key, defaultValue, defaultOptions);
      _options = defaultOptions;
    }
  } else {
    cookie.value = value;
  }
  const setCookie = (newValue, options) => {
    cookie.value = newValue;
    _options = options;
    api.set(key, cookie.value, _options);
  };
  const removeCookie = () => {
    cookie.value = void 0;
    api.remove(key, _options);
  };
  watch(cookie, (cookie2, prevCookie) => {
    if (isUndefined(cookie2) || isNull(cookie2)) {
      api.remove(key, _options);
    } else if (cookie2 !== prevCookie) {
      api.set(key, cookie2, _options);
    }
  }, {
    deep: true
  });
  return {
    cookie,
    setCookie,
    removeCookie
  };
}
export {
  useCookie
};
/*! Bundled license information:

js-cookie/dist/js.cookie.mjs:
  (*! js-cookie v3.0.5 | MIT *)
*/
//# sourceMappingURL=@vue-composable_cookie.js.map
